template engine
timing task

passport
dashboard


https://fancy.com/hongquanli
infinite
thymeleaf

System.setProperty("spring.profiles.active", "production");

MQTT

Kotlin in Action
Kotlin for Android Developers
https://light.hs.net/portal/not-support.html


lightart/github

encyclopedia
Scalable
Resources

快速清空文件内容：
　　$ : > filename #其中的 : 是一个占位符, 不产生任何输出.
　　$ > filename
　　$ echo '' > filename
　　$ echo /dev/null > filename
　　$ echo > filename
　　$ cat /dev/null > filename


泛化、继承、实现、依赖、关联、聚合、组合
单例 多例 静态 线程安全

Behavior
Event
Action
Command

Service

Request
Response
Context
Data

Content-Type: MIME
.xml text/xml
.json text/json

SearchCriteria

attachment
encoding
version

Backup
Data
Temp
Video
Attachment
Config
Image
Favorite
Docs

prototype

singleton

Resources
Representation
State Transfer

ConfigurableBeanFactory
AbstractBeanFactory

Search criteria/command


support

// Request
{
    access_key:'',
    source_address:'C0-3F-D5-E5-20-51',
    mac:'',
    compress_algorithm:''
    signature_algorithm:''
    encrypt_algorithm:'',
    signature:'',
    version:'1.0',
    service:'Behavior, Event, Action, Command',
    content_type:'text/json',
    encoding:'UTF-8',
    timestamp:'1445950906202',
    description:'',
    arguments:{
        'props':{

        }
    },
    data:{
        offset:'',
        limit:'',
        content:''
    }
}

// Response
{
    path:'',
    service:'',
    status:'',
    message:'',
    error:'',
    timestamp:'1445950906202',
    version:'1.0',
    content_type:'text/json',
    encoding:'UTF-8',
    description:'',
    arguments:{
        'props':{

        }
    },
    data:{
        page_number:'Behavior, Event, Action, Command',
        page_size:20,
        total_elements:'',
        total_pages:'',
        is_first:true,
        is_last:false,
        has_next:'',
        has_previous:'',
        content:{
            // ......
        }
    }
}


target

{
    “userKey”: “975bf42bdf837a1e43508a9bf6340420”,
    “sourceAddress”: “120.2.6.5”,
    “mac”: “C0-3F-D5-E5-20-51”,
    “compressAlgorithm”: “gzip”,
    “signatureAlgorithm”: “”,
    “encryptAlgorithm”: “”,
    “signature”: “”,
    “encoding”: “UTF-8”,
    “version”: “1.0”,
    “timestamp”: “1445950906202”,
    “description”: “”,
    “arguments”: {
        “props”: {
            “key”: “value”,
            ……
        }
    }
}

{
    “responseCode”: “”,
    “responseMessage”: “”,
    “compressAlgorithm”: “gzip”,
    “signatureAlgorithm”: “”,
    “encryptAlgorithm”: “”,
    “serviceResponseCode”: “”,
    “serviceResponseMessage”: “”,
    “exceptionDetail”: “”,
    “encoding”: “UTF-8”,
    “version”: “1.0”,
    “timestamp”: “1445950906202”,
    “description”: “”,
    “arguments”: {
        “props”: {
            “key”: “value”,
            ……
        }
    }
}






企业各职位英文缩写：
GM(General Manager)总经理
VP(Vice President)副总裁
FVP(First Vice President)第一副总裁
AVP(Assistant Vice President)副总裁助理
CEO(Chief Executive Officer)首席执行官，类似总经理、总裁，是企业的法人代表。
COO(Chief Operations Officer)首席运营官，类似常务总经理
CFO(Chief Financial Officer)首席财务官，类似财务总经理
CIO(Chief Information Officer)首席信息官，主管企业信息的收集和发布
CTO(Chief technology officer)首席技术官 类似总工程师
HRD(Human Resource Director)人力资源总监
OD(Operations Director)运营总监
MD(Marketing Director)市场总监
OM(Operations Manager)运作经理
PM(Production Manager)生产经理 (Product Manager)产品经理

其他：
CAO: Art 艺术总监
CBO: Business 商务总监
CCO: Content 内容总监
CDO: Development 开发总监
CGO: Gonverment 政府关系
CHO: Human resource 人事总监
CJO: Jet 把营运指标都加一个或多个零使公司市值像火箭般上升的人
CKO: Knowledge 知识总监
CLO: Labour 工会主席
CMO: Marketing 市场总监
CNO: Negotiation 首席谈判代表CPO: Public relation 公关总监
CQO: Quality control 质控总监
CRO: Research 研究总监
CSO: Sales 销售总监
CUO: User 客户总监
CVO: Valuation 评估总监
CWO: Women 妇联主席
CXO: 什么都可以管的不管部部长
CYO: Yes 什么都点头的老好人
CZO: 现在排最后，等待接班的太子

*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*
*******************************************
            ╭╮　　　　　　　╭╮　　
          　││　　　　　　　││　　
          ╭┴┴———————┴┴╮
          │　　　　　　　　　　　│　　　
          │　　　　　　　　　　　│　　　
          │　●　　　　　　　●　│
          │○　　╰┬┬┬╯　　○│
          │　　　　╰—╯　　　　│　
          ╰——┬Ｏ———Ｏ┬——╯
　 　           ╭╮　　　　╭╮　　　　
　            　╰┴————┴╯
  ╭══╮
╭╯ΘΘ ║
╰⊙═⊙╯。oо○Thanks & BestRegards  *^o^*

SwarmKit

http://java-design-patterns.com/
https://github.com/hoohack/DesignPattern

MQTT

http://iot.eclipse.org/projects


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Sign up
Sign in/Log in
Sign out

console/workbench/dashboard/main

merchant
  products
  orders
  insights
  promote
    coupons
      Add New Coupon
  campaigns
    Create Campaign
  settings
    account
      The Basics
    general
      Brand Image
    shipping/preferences
      Shipping Rules
    policy
      Policies
    payment
    storefront
      Storefront
    notifications
      Notifications
  faq
    about/merchants/resources/faq



  cart
  settings
    profile
      Edit Profile
      Deactivate my account
    preferences
      Edit Preferences
    password
    notifications
      Notifications
    accounts
      Connected Accounts
    purchases
      Orders
    cards
      Payment Methods
    shipping
      Shipping Addresses
    credits
      credit
      referrals
      giftcards


    lists
    wishlist
    likes

report


connect?source=qq

topic
article

commodity/product/goods
goods,commodity,product,merchandise,wares这些名词都可表示“商品,货物”之意.
products是产品
goods是物品
commodity是日用品
merchandise是货物
详细点就是：
goods一般生活或商业用词,指销售或购入的商品.Goods 货物!
commodity作“商品”解时系经济学名词,也可指日用品.
product一般指工业产品,也可泛指各种各样的产品.
merchandise正式用词,指商业上销售或商家拥有货物的总称.
wares 指上市待卖的商品或货物.多用复数形式.
merchandise 商品,泛指商品,不特指某一商品

order

shopping cart


市场价 retail price
加盟价 franchise price
会员价 member price
商品单位 product unit
数量 amount
编号 product ID
单位 unit
类别 category
产品介绍 product description

对不起，您还没有登陆 sorry, you didn't log in yet.
添加购物 add to shopping cart
商品已经成功添加您的购物车 product added to your shopping cart
商品数量修改成功 product amount modified successfully
购物车被清空 your shopping is emptied (Your shopping cart is empty)
删除成功 deleted successfully

您从何处知道本网站  Where you heard our site from

递交 submit
重写 reset

你的数据添加成功 your information added successfully
你的数据添加失败 add information failed

申请会员成功 membership successfully registered
申请失败 membership apply failed










Payment method

Order summary

Choose a shipping address
Review order




Share
Share this with friends
Lists
Save this to your profile



活锁

------------------------------------------------------------------------------------------------------------------------
解决Tomcat catalina.out 不断成长导致档案过大的问题
Tomcat的网站上的说法http://wiki.apache.org/tomcat/FAQ/Logging#Q6：
System.out 和 System.err 都被打印到 catalina.out。
catalina.out 不会 rotate。
如果您使用了 logging 机制，就不会有任何东西被写到标准输出了，所以这应该不会是个问题。
可是实际上发现，虽然有设了log4j之类的 logging 机制，但写程序的人如果还是写成System.out.println()或是遇到exception时都来个e.printStackTrace()，这些输出最后还是通通送到catalina.out去了。日子久了，这个档案还是会日渐变大起来，如果没有加以管理最后就会长大成好几GB的庞然大物。（这时千万不要再用vi去开它了。）
网络上找了一下，针对在Linux环境下执行Tomcat的部份，发现有个不错的工具软件cronolog可以协助Web Server之类的做 log 檔的 rotate，详细的运作原理可能大家得自己去这个网站上查，我的认知大致如下：
Tomcat先把输出写到 console(标准输出) 然后透过 pipe (|) 转为 cronolog 的输入，由cronolog针对一个事先给定的文件名的命名规则，去过滤数据，定期关闭旧文件，然后再开启新档。如果我们将文件名的命名规则设为catalina.out.%Y-%m-%d，就可以做到每天开一个新的catalina.out.yyyy-mm-dd的档案了。
以下是简单的过程说明：
1.安装cronolog
2.修改catalina.sh
3.重新启动Tomcat

1 安装cronolog
wget http://cronolog.org/download/cronolog-1.6.2.tar.gz
tar zxvf cronolog-1.6.2.tar.gz
cd cronolog-1.6.2
./configure
make
make install

用which cronolog可以查到安装的路径，默认应该是/usr/local/sbin/cronolog，这个路径待会在修改catalina.sh时会用到。
2 修改catalina.sh
以Tomcat 6.0.24的版本为例
2.1 第一步
将
if [ -z "$CATALINA_OUT" ] ; then
CATALINA_OUT="$CATALINA_BASE"/logs/catalina.out
fi
修改为
if [ -z "$CATALINA_OUT" ] ; then
CATALINA_OUT="$CATALINA_BASE"/logs/catalina.out.%Y-%m-%d
fi
2.2 第二步
将
touch "$CATALINA_OUT"
改为
#touch "$CATALINA_OUT"
2.3 第三步
将
org.apache.catalina.startup.Bootstrap "$@" start /
>> "$CATALINA_OUT" 2>&1 &
修改为
org.apache.catalina.startup.Bootstrap "$@" start 2>&1 /
| /usr/local/sbin/cronolog "$CATALINA_OUT" >> /dev/null &
2.4 重新启动Tomcat
service tomcat restart
可以在Tomcat的logs目录底下找到以系统日期为结尾的catalina.out.yyyy-mm-dd的档案，这样子就成功了。
后续就是持续观察看看是不是每天都有产生一个新的catalina.out.yyyy-mm-dd档案。然后再安排定期删除这些较旧的log檔即可。


Linux下的tomcat产生的日志文件不象windows下的按时间时间和大小来处理，
尽管也生成了日志文件catalina.2009-0x-0x.log类型的文件，但是其中的catalina.out文件依然增大；它为啥在增大，为啥在增大，原因我就不探究了。

Tomcat的官方文档，由于是外文，偶还没有看明白di；
http://tomcat.apache.org/tomcat-6.0-doc/logging.html
据说是修改某些配置可以实现，希望高人指点，给个官方的解决方案；
老是增大也不是办法，还是想其他办法搞定它为好：
方法1—分割流
使用cronolog工具切分Tomcat的catalina.out日志文件
cronolog一个对日志切分的小工具，其主页在http://cronolog.org/，我们也可以用它来切分Apache的日志。
具体的方法，您可以去google之，这个方法占网络搜索结果的主流；
方法2—脚本流
事情终究不过是个大文件处理的问题，强大的bash来搞定；
使用cron每天来备份当前的catalina.out，然后清空他的内容；
参考脚本如下：
#!/bin/sh
y=`date "+%Y"`
m=`date "+%m"`
d=`date "+%d"`
cd /PATH /tomcat/logs
cp catalina.out catalina.out.$y$m$d
echo > catalina.out
exit
注意linux系统的cron服务是否启动，是否正常工作，还有脚本的存放路径（原因暂保密）

方法3—猥琐流
打开bin目录下的catalina.sh文件，终究不过是个bash文件，
查找一下，catalina.out总共出现三次；
部分截图：
shift
touch "$CATALINA_BASE"/logs/catalina.out
if [ "$1" = "-security" ] ; then
    echo "Using Security Manager"
    shift
    "$_RUNJAVA" $JAVA_OPTS "$LOGGING_CONFIG" $CATALINA_OPTS \
      -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \
      -Djava.security.manager \
      -Djava.security.policy=="$CATALINA_BASE"/conf/catalina.policy \
      -Dcatalina.base="$CATALINA_BASE" \
      -Dcatalina.home="$CATALINA_HOME" \
      -Djava.io.tmpdir="$CATALINA_TMPDIR" \
      org.apache.catalina.startup.Bootstrap "$@" start \
      >> "$CATALINA_BASE"/logs/catalina.out 2>&1 &
      if [ ! -z "$CATALINA_PID" ]; then
        echo $! > $CATALINA_PID
      fi
else
    "$_RUNJAVA" $JAVA_OPTS "$LOGGING_CONFIG" $CATALINA_OPTS \
      -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \
      -Dcatalina.base="$CATALINA_BASE" \
      -Dcatalina.home="$CATALINA_HOME" \
      -Djava.io.tmpdir="$CATALINA_TMPDIR" \
      org.apache.catalina.startup.Bootstrap "$@" start \
      >> "$CATALINA_BASE"/logs/catalina.out 2>&1 &
个人觉得也就是这里是写catalina.out文件的；让他写到一个其他的空设备如何？
修改前注意原文件的catalina.sh的备份哟~！！
修改以上代码中的
>> "$CATALINA_BASE"/logs/catalina.out 2>&1 &
为
>> /dev/null 2>&1 &
保存，然后启动tomcat，目前这个 catalina.out一直是空的了。
这个方法是偶自己想到的，个人认为比较勇敢，目前还没有在生产环境测试过。虚拟机测试是通过的。

方法4—人流
这个方法其实就是linux系统管理员手工去删除，人工操作，简称“人流”；
删除之前最好停止tomcat的服务；
------------------------------------------------------------------------------------------------------------------------


Paxos和Raft
Consensus

Nginx（或Haproxy） +keepalived

Keepalived
ZooKeeper

http://thesecretlivesofdata.com/raft/
CAP原理和BASE思想
http://www.jdon.com/37625
分布式系统Paxos算法
http://www.jdon.com/artichect/paxos.html

2PC到3PC到Paxos到Raft到ISR
https://segmentfault.com/a/1190000004474543

射线光学理论



<servlet>
    <servlet-name>chapter2</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-servlet-config.xml</param-value>
    </init-param>
</servlet>


RabbitMq、ActiveMq、ZeroMq、kafka
http://flume.apache.org/
https://github.com/facebookarchive/scribe
http://chukwa.apache.org/
http://flink.apache.org/
http://kafka.apache.org/

jackson
com.fasterxml.jackson
http://community.jaspersoft.com/project/jasperreports-library
https://github.com/flexpaper/pdf2json
https://flowpaper.com/download/
https://github.com/flexpaper/flexpaper

Libxml
http://xmlsoft.org/

lua
http://www.lua.org/

libpng
http://www.libpng.org/

json
http://www.json.org/json-zh.html


XML、JSON、ProtocolBuffer、Lua
http://lua-users.org/wiki/JsonModules



Zookeeper在集群负载均衡中的应用
Zookeeper本身是不提供负载均衡的策略,需要自己来实现，所以这里确切的说，是在负载均衡中应用到了Zookeeper做集群的协调。
对于HTTP请求的负载均衡，成熟的解决方案是Nginx（或Haproxy） +keepalived。其中Niginx负责代理HTTP请求，通过某种均衡策略访问集群中的服务器，keepalived负责检测集群中的服务器运行情况（有故障的机器移除，机器恢复工作后重新加入）
而对于TCP层的负载均衡，比如用Apache Mina做的网络通信应用，上面那种方案明显不适合，因为网络通信客户端和服务端要保持长连接
所以要针对这种长连接做负载均衡，一般都是基于连接数这种均衡策略，也就是在第一次连接时，分配服务器IP时，取当前连接数最少的那台
集群中有几台服务器处于运行状态，每一台服务器当前连接的客户数量，最大连接数量，等等这些信息需要记录起来，然后每次做负载均衡时根据这些信息来做分配，一般首先想到的是把这些信息存放在数据库里
简单的做法就是服务器启动时，把数据库里相应的状态改为运行，有客户连接或断开时，把连接数做加数或减数运算。
当服务器关闭时，问题就来了：
1、服务器关闭，可能数据源也已经被关闭，没法操作数据库，该机器在数据库里一直处于运行状态
2、服务器宕机，这种问题就很致命，这是连关闭的程序都没有执行，更不用说能操作数据库了
解决的方式就是用Zookeeper保存服务器的连接信息
1、当服务器启动时，往Zookeeper的节点里写入数据（节点类型是临时节点）
2、当服务器关闭时，从Zookeeper移除相应的节点数据
3、当服务器宕机，Zookeeper因为没有检测到心跳，自动把该节点移除，并通知其他服务器，其他服务器得知该机器已宕机，在分配连接时，不会分配到这台机器上，这点也是标题说的在负载均衡中用到Zookeeper的原因。
对比了一下保存在数据库那种方式，Zookeeper其实就是一个具有通知功能的数据库，也就是它底下节点数据有变化时，会通知它的所有客户端（这里的客户端指的连接到Zookeeper的服务器）。


HA和负载均衡的区别
1、HA（High Available）：主要解决可靠性问题，设备、部件的互备等，通过技术也可以实现部分的流量负载分担功能。
　常见的有服务器的HA，俗称双机热备；
　网络的HSRP/vrrp/glp，以及各厂商的私有技术，像cisco防火墙的failover，juniper防火墙的nsrp等等。
2、负载均衡：可分为网络层面和应用层面
　网络层面一般可能使用端口聚合、多路径等技术，主要在网络层面实现流量负载均衡。
　应用层面的负载均衡，主要厂商有F5、radware、cisco等等，通过专用的负载均衡设备实现基于不同应用类型的负载均衡。
两个就不是一回事，不可相比，一个用于设备冗灾，一个用于流量分分担

HA
http://blog.csdn.net/e421083458/article/details/30092795
http://www.cnblogs.com/holbrook/archive/2012/10/25/2738475.html
https://yq.aliyun.com/articles/24155
http://blog.sina.com.cn/s/blog_4e424e2101007rie.html

OpenVPN
OpenGl
WebGl


http://www.firewalld.org/documentation/howto/open-a-port-or-service.html


x        删除当前光标下的字符
dw       删除光标之后的单词剩余部分。
d$       删除光标之后的该行剩余部分。
dd       删除当前行。

c        功能和d相同，区别在于完成删除操作后进入INSERT MODE
cc       也是删除当前行，然后进入INSERT MODE
删除每行第一个字符    :%s/^.//g


同步时间
ntpdate 172.16.0.1


证明（递归）、算法（递归）、语言（λ演算[10]）、操作系统（指针）、编译器（λ演算）


服务发现 zookeeper ,consul ,etcd
zipkin为分布式链路调用监控系统，聚合各业务系统调用延迟数据，达到链路调用监控跟踪。

netflix
zuul用来提供动态路由、监控、授权、安全、调度等等的边缘服务(edge service)。
feign是一个类似retrofit进行http调用框架，Feign makes writing Java http clients easier 使得编写http client代码更加简单。
eureka 用以服务发现、服务注册，比较流行的有consul。
ribbon用以实现负载均衡；实现软负载均衡，核心有三点：
1.服务发现，发现依赖服务的列表
2.服务选择规则，在多个服务中如何选择一个有效服务
3.服务监听，检测失效的服务，高效剔除失效服务
turbine是聚合服务器发送事件流数据的一个工具，hystrix的监控中，只能监控单个节点，实际生产中都为集群，因此可以通过turbine来监控集群下hystrix的metrics情况，通过eureka来发现hystrix服务。
hystrix通过服务隔离、熔断(也可以称为断路)、降级等手段控制依赖服务的延迟与失败。

http://www.ruanyifeng.com/


两种I/O多路复用模式：Reactor和Proactor

RxJava: Reactive Extensions for the JVM
Querydsl
https://ebean-orm.github.io/
http://ignite.apache.org/
https://www.consul.io


 MATLAB和Mathematica、Maple并称为三大数学软件

 布隆过滤器(Bloom Filter)

SNMP

BPEL：全称为Business Process Execution Language,即业务流程执行语言，是一种使用XML编写的编程语言。用于自动化业务流程，也曾经被称作WSBPEL和 BPEL4WS。广泛使用于Web服务相关的项目开发中，优点为具有可移植性和有效保护了投资。


Spring Security

under active development.
has much more community support.
Spring security has extensions providing support for both Oauth and kerberos and SAML.

Shiro

Does not support saml or Oauth.
Makes no mention of supporting before and after security policies.
Active development seems limited, the website still contains erroneous information.


DevOps


领域通用语言（UBIQUITOUS LANGUAGE）
UnitOfWork
Factory
Repository
Event Sourcing
Aggregate，Aggregate Root
Domain Service
Value Object
Entity

User Interface
Application
Domain
Infrastructure

事务
池化
虚拟
存储
协议
算法


一,事务的4个基本特征
Atomic（原子性）：
事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。
Consistency（一致性）：
只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。
Isolation（隔离性）：
事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。
Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。
二,为什么需要对事务并发控制
如果不对事务进行并发控制，我们看看数据库并发操作是会有那些异常情形
Lost update：
两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。
Dirty Reads：
一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚。
Non-repeatable Reads： 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。
Second lost updates problem： 无法重复读取的特例。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。
Phantom Reads：
事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。
三, 数据库的隔离级别
为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（Oracle和SQLSERER对标准隔离级别有不同的实现 ）
Read Uncommitted：
直译就是"读未提交",意思就是即使一个更新语句没有提交,但是别的事务可以读到这个改变.这是很不安全的.
Read Committed：
直译就是"读提交",意思就是语句提交以后即执行了COMMIT以后别的事务就能读到这个改变.
Repeatable Read：
直译就是"可以重复读",这是说在同一个事务里面先后执行同一个查询语句的时候,得到的结果是一样的.
Serializable:
直译就是"序列化",意思是说这个事务执行的时候不允许别的事务并发执行.
四，隔离级别对并发的控制
下表是各隔离级别对各种异常的控制能力。
 	LU	DR	NRR	SLU	PR
RU	Y	Y	Y	Y	Y
RC	N	N	Y	Y	Y
RR	N	N	N	N	Y
S	N	N	N	N	N
(注：LU：丢失更新；DR：脏读；NRR：非重复读；SLU：二类丢失更新；PR：幻像读)



Hibernate占位符问题[use named parameters or JPA-style positional parameters instead.]

hibernate 4.1之后对于HQL中查询参数的占位符做了改进，如果仍然用老式的占位符会有类似如下的告警信息：

[main] WARN  [org.hibernate.hql.internal.ast.HqlSqlWalker] – [DEPRECATION] Encountered positional parameter near line 1, column 95.  Positional parameter are considered deprecated; use named parameters or JPA-style positional parameters instead.
从告警提示信息中可以看出，它建议用命名参数或者JPA占位符两中种方法来代替老的占位符查询方法。

比如老的占位符查询代码片段：
String hql = "select t from Blog t where t.site=?";
Query query = getSession().createQuery(hql);
query.setParameter(0, "simple.com");
方法一：改成命名参数的方式：

// 命名参数的方式
String hql2 = "select t from Blog t where t.site=:site";
Query query2 = getSession().createQuery(hql2);
query2.setParameter("site", "simple.com");
方法二：改成JPA占位符的方式：

// JPA占位符方式
String hql3 = "select t from Blog t where t.site=?0";
Query query3 = getSession().createQuery(hql3);
query2.setParameter(0, "simple.com");
其中"?"后面的"0"代表索引位置，在HQL语句中可重复出现，并不一定要从0开始，可以是任何数字，只是参数要与其对应上。


EventSource

sveltejs
vuejs
cyclejs

Kubernetes
TensorFlow

Lamda

Trie树

------------------------------------------------------------------------------------------------------------------------
http://blog.jobbole.com/30940/

LFU Least Frequently Used 最近最少使用算法，一定时间段内使用次数（频率）最少的那个被移除；
LRU Least Recently Used 最久未使用算法，使用时间距离现在最久的那个被移除；
LRU2 Least Recently Used 2 最少使用 twice
LIRS Low Inter-reference Recency Set
ARC Adaptive Replacement Cache
MRU Most Recently Used
FIFO First in First out 先进先出算法，即先放入缓存的先被移除；
Second Chance
CLock
Simple time-based
Extended time-based expiration
Sliding time-based expiration
LeftOver 机制
Random Cache


Two Queues（2Q）

1.最佳置换算法(Optimal)：它是由Belady于1966年提出的一种理论上的算法。其所选择的被淘汰页面，将是以后永不使用的或许是在最长(未来)时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。但由于人目前还无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的，便可以利用此算法来评价其它算法。
2.先进先出(FIFO)页面置换算法：这是最早出现的置换算法。该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。
3.LRU置换算法：这是本次设计的重点。
4.CLOCK置换算法：a,简单CLOCK置换算法；b,改进型CLOCK算法。LRU算法是较好的一种算法，而由于LRU在硬件上要求较多，在实际应用中多采用LRU的近似算法。CLOCK算法就是用得较多的一种LRU近似算法。
5.最少使用(LFU:Least Frequently Used)置换算法：在采用该算法时，应为在内存中的每个页面设置一个移位寄存器骼来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面为淘汰页。
6.页面缓冲算法(PBA：Page Buffering Algorithm)

TTL（Time To Live ）
存活期，即从缓存中创建时间点开始直到它到期的一个时间段（不管在这个时间段内有没有访问都将过期）

TTI（Time To Idle）
空闲期，即一个数据多久没被访问将从缓存中移除的时间。

缓存命中率

即从缓存中读取数据的次数 与 总读取次数的比率，命中率越高越好：
命中率 = 从缓存中读取次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数])
Miss率 = 没有从缓存中读取的次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数])
------------------------------------------------------------------------------------------------------------------------

GB/T 7714-2005
制定机构：国家质量监督检验检疫总局和中国标准化管委会
适用范围：国内发表刊物（自然科学国际上采用AMA格式，新闻报刊采用Chicago格式）
引用格式：作者名+作品名+标识码+刊物名+年份+刊号+页码
插注格式：中括号扩上数字标号，加上标  e.g. XXX[3]
Borst S, Gupta V, Walid A. Distributed Caching Algorithms for Content Distribution Networks[C]// Conference on Information Communications. IEEE Press, 2010:1478-1486.

APA
制定机构：美国心理学会 American Psychological Association
适用范围：主要是心理学、教育学、社会科学
引用格式：作者名+年份+作品名+刊物名斜体+刊号斜体+页码
插注格式：“作者和日期”的引用方式和“括号内引用法”  e.g. (ABC, 1999)
Borst, S., Gupta, V., & Walid, A. (2010). Distributed Caching Algorithms for Content Distribution Networks. Conference on Information Communications (Vol.54, pp.1478-1486). IEEE Press.

MLA
制定机构：美国现代语言协会 Modern Language Association
适用范围：主要人文学科，如文学、比较文学、文学批评和文化研究等
引用格式：作者名+引号作品名+刊物名斜体+刊号+年份+页码
插注格式：作者加页码的引用，不在引用时标注日期  e.g. (ABC 53)
Borst, S, V. Gupta, and A. Walid. "Distributed Caching Algorithms for Content Distribution Networks." Conference on Information Communications IEEE Press, 2010:1478-1486.


title="Cost-aware WWW proxy caching algorithms",
author="Cao, Pei and Irani, Sandy",
booktitle={Usenix Symposium on Internet Technologies and Systems on Usenix Symposium on Internet Technologies and Systems},
pages="18-18",
year="1997",


物理内存、页面文件、交换区和虚拟内存

------------------------------------------------------------------------------------------------------------------------
/etc/sysconfig/i18n 这里存放的是系统的区域语言设置， i18n是  国际化internationalization的缩写 i和n之间正好18个字母
第一行  表明你当前系统的语言环境变量设置 ，这里是 zh_CN.GB18030
第二行  表明系统预置了那些语言支持 ，不在项目中的语言不能正常显示
第三行  定义控制台终端字体，你文本登录的时候显示的字体就是这个 latarcyrheb-sun16

设置中文编码
$vi /etc/sysconfig/i18n
内容如下：
LANG="zh_CN.UTF-8"
SUPPORTED="zh_CN:zh:en_US.UTF-8:en_US:en:zh_CN.GB18030"
SYSFONT="latarcyrheb-sun16"

让配置生效
$source /etc/sysconfig/i18n

------------------------------------------------------------------------------------------------------------------------

Moore状态机和Mealy状态机


XML、JSON、ProtocolBuffer、Lua

anonymous,guest


ntpdate cn.pool.ntp.org
更新完后要用 clock -w 或 hwclock -w 实时间写入到BIOS中，这样下次启动时，时间就会自动更新了。


------------------------------------------------------------------------------------------------------------------------
Linux下清理内存和Cache方法 /proc/sys/vm/drop_caches

频繁的文件访问会导致系统的Cache使用量大增

$ free -m
total used free shared buffers cached
Mem: 3955 3926 28 0 55 3459
-/+ buffers/cache: 411 3544
Swap: 5726 0 5726

free内存减少到几十兆，系统运行缓慢

运行sync将dirty的内容写回硬盘
$sync

通过修改proc系统的drop_caches清理free的cache
$echo 3 > /proc/sys/vm/drop_caches

drop_caches的详细文档如下：
Writing to this will cause the kernel to drop clean caches, dentries and inodes from memory, causing that memory to become free.
To free pagecache:
* echo 1 > /proc/sys/vm/drop_caches
To free dentries and inodes:
* echo 2 > /proc/sys/vm/drop_caches
To free pagecache, dentries and inodes:
* echo 3 > /proc/sys/vm/drop_caches
As this is a non-destructive operation, and dirty objects are notfreeable, the user should run "sync" first in order to make sure allcached objects are freed.
This tunable was added in 2.6.16.

  修改/etc/sysctl.conf 添加如下选项后就不会内存持续增加
vm.dirty_ratio = 1
vm.dirty_background_ratio=1
vm.dirty_writeback_centisecs=2
vm.dirty_expire_centisecs=3
vm.drop_caches=3
vm.swappiness=100
vm.vfs_cache_pressure=163
vm.overcommit_memory=2
vm.lowmem_reserve_ratio=32 32 8
kern.maxvnodes=3

上面的设置比较粗暴，使cache的作用基本无法发挥。需要根据机器的状况进行适当的调节寻找最佳的折衷。
------------------------------------------------------------------------------------------------------------------------

framebuffer
Cairo
Skia
FreeType
xlib x.org


------------------------------------------------------------------------------------------------------------------------
Firebase Meteor

什么是 Meteor？
Meteor 是一种新的 JavaScript 框架，用于自动化和简化实时运行的 Web 应用程序的开发。它使用一个名为分布式数据协议 (Distributed Data Protocol, DDP) 的协议来处理实时通信，使用 WebSockets 的新浏览器以及使用 Asynchronous JavaScript + XML (Ajax) 长轮询的旧浏览器来支持这种协议。在这两种情况下，浏览器到服务器的通信是透明的。
DDP 协议旨在处理 JavaScript Serialized Object Notation (JSON) 文档集合，使 JSON 文档容易创建、更新、删除、查询和访问。因为 DDP 是一种开源协议，所以您可将它连接到任何客户端或数据存储。它为 MongoDB 提供了开箱即使用支持。
事实上，Meteor 提供了两个 MongoDB 数据库：一个客户端缓存数据库和服务器上的一个 MongoDB 数据库。当一个用户更改一些数据时（例如通过单击 Save），在浏览器中运行的 JavaScript 代码会更新本地 MongoDB 中的相应的数据库项，然后向服务器发出一个 DDP 请求。该代码立即像操作已获得成功那样继续运行，因为它不需要等待服务器回复。与此同时，服务器在后台更新。如果服务器操作失败或返回一个意外结果，那么客户端 JavaScript 代码会依据从服务器新返回的数据立即进行调整。这种调整称为延迟补偿，向用户提供了更高的认知速度。
显然，甚至连 Meteor 的模板系统也是为简化实时通信而设计的。在大多数 Web 框架中，您可以轻松地混合使用超文本标记语言 (HTML) 和代码，或者与 HTML 等效的标记，比如 HTML 抽象标记语言 (Haml)。这使您能够轻松地将来自数据库的动态值插入发送给用户的页面中。在这之后，您应该负责准备提供一个系统来观察对数据的更改，然后更新您的标记。但是，Meteor 中的模板系统用于记录访问了模板中的哪些数据，并自动回调，以便在底层数据更改时调用此 HTML，使实时模板变得更加简单快捷。

------------------------------------------------------------------------------------------------------------------------
什么是中断
Linux 内核需要对连接到计算机上的所有硬件设备进行管理，毫无疑问这是它的份内事。如果要管理这些设备，首先得和它们互相通信才行，一般有两种方案可实现这种功能：
轮询（polling） 让内核定期对设备的状态进行查询，然后做出相应的处理；
中断（interrupt） 让硬件在需要的时候向内核发出信号（变内核主动为硬件主动）。
第一种方案会让内核做不少的无用功，因为轮询总会周期性的重复执行，大量地耗用 CPU 时间，因此效率及其低下，所以一般都是采用第二种方案 。

------------------------------------------------------------------------------------------------------------------------
http://ramdajs.com/


master slave backup

gzip是一种数据格式，默认且目前仅使用deflate算法压缩data部分；
deflate是一种压缩算法,是huffman编码的一种加强。


gcc生成.a静态库和.so动态库文件

o 生成静态库的方法
$ gcc -c gdfontwu.c
$ gcc -c gdfontliu.c
$ gcc -c gdfontbin.c
$ ar rc libgdfont.a gdfontwu.o gdfontliu.o gdfontbin.o
(ranlib libgdfont.a 可生成索引)
用 nm libgdfont.a 来看里面的目标文件和导出函数（带 T 标记）。

o 生成动态库的方法
$ gcc -c gdfontwu.c
$ gcc -c gdfontliu.c
$ gcc -c gdfontbin.c
$ gcc -o libgdfont.so -shared -fPIC gdfontwu.o gdfontliu.o gdfontbin.o
-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码
是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程
需要，而不能达到真正代码段共享的目的。可用 nm libgdfont.so 来看
里面导出的函数（带 T 标记）。
用动态库的好处是：更新了动态库之后链结它的程序不用重新编译。

o 用法
在 websrv.c 中：
/* websrv.c */
#include "gdfontwu.h"
#include "gdfontliu.h"
#include "gdfontbin.h"
int getpng()
{
    ...
    gdImageChar(..., gdFontWu, ...);
    gdImageChar(..., gdFontLiu, ...);
    gdImageChar(..., gdFontBin, ...);
    ...
    return 0;
}
> 静态库:
$ gcc -c websrv.c
$ gcc -o websrv websrv.o libgdfont.a

> 动态库：
$ gcc -o websrv websrv.o -L. -lgdfont
$ LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH ./websrv
LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH ldd main
可以看到 websrv 程序所链结的动态库。把 libgdfont.so 放到
/etc/ld.so.conf 中列出的目录下就可以不用先指定环境变
，注意先 ldconfig 刷新系统动态库的缓存
还有一种 ld -rpath dir 这样的方法可避免设定环境变量

RxJava
http://reactivex.io/languages.html

https://www.x.org/wiki/
X11/Xlib
framebuffer

https://www.viksoe.dk/code/

https://tronche.com/gui/x/xlib-tutorial/2nd-program-anatomy.html
https://tronche.com/gui/x/xlib/
https://www.x.org/docs/X11/xlib.pdf


http://www.jianshu.com/u/1f0067e24ff8

三面娜迦





Cron Expressions
1）Cron表达式的格式：秒 分 时 日 月 周 年(可选)。

Cron Expressions Allowed Fields and Values
字段名(Name)          Required       允许的值(Allowed Values)        允许的特殊字符(Allowed Special Characters)
秒(Seconds)          Y              0-59                           , - * /
分(Minutes)          Y              0-59                           , - * /
时(Hours)            Y              0-23                           , - * /
日(Day-of-Month)     Y              1-31                           , - * ? / L W C
月(Month)            Y              0-11 or JAN-DEC                , - * /
周(Day-of-Week)      Y              1-7 or SUN-SAT                 , - * ? / L C #
年(Year 可选)         N              empty, 1970-2099               , - * /

“*”字符：代表整个时间段.
“?”字符：表示不确定的值
“,”字符：指定数个值
“-”字符：指定一个值的范围
“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m
“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X
“W”字符：指定离给定日期最近的工作日(周一到周五)
“#”字符：表示该月第几个周X。6#3表示该月第3个周五

每一个字段都有一套可以指定有效值，如
Seconds(秒)：可以用数字0－59 表示，
Minutes(分)：可以用数字0－59 表示，
Hours(时)：可以用数字0-23表示,
Day-of-Month(天)：可以用数字1-31 中的任一一个值，但要注意一些特别的月份
Month(月)：可以用0-11 或用字符串  “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示
Day-of-Week(每周)：可以用数字1-7表示（1 ＝ 星期日）或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”表示

“*”: 代表整个时间段.
“/”：为特别单位，表示为“每”如“0/15”表示每隔15分钟执行一次,“0”表示为从“0”分开始, “3/20”表示表示每隔20分钟执行一次，“3”表示从第3分钟开始执行
“?”：表示每月的某一天，或第周的某一天
“L”：用于每月，或每周，表示为每月的最后一天，或每个月的最后星期几如“6L”表示“每月的最后一个星期五”
“W”：表示为最近工作日，如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”
“#”：是用来指定“的”每月第n个工作日,例 在每周（day-of-week）这个字段中内容为"6#3" or "FRI#3" 则表示“每月第三个星期五”

例:"0 0 12 ? * WED" 在每星期三下午12:00 执行,("WED")可以替换成 "MON-FRI", "MON, WED, FRI"甚至"MON-WED,SAT".

2）Cron表达式范例：
每隔5秒执行一次：*/5 * * * * ?
每隔1分钟执行一次：0 */1 * * * ?
每天23点执行一次：0 0 23 * * ?
每天凌晨1点执行一次：0 0 1 * * ?
每月1号凌晨1点执行一次：0 0 1 1 * ?
每月最后一天23点执行一次：0 0 23 L * ?
每周星期天凌晨1点实行一次：0 0 1 ? * L
在26分、29分、33分执行一次：0 26,29,33 * * * ?
每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?

Here are some more examples:

Expression	                Means
0 0 12 * * ?	        	Fire at 12:00 PM (noon) every day
0 15 10 ? * *	        	Fire at 10:15 AM every day
0 15 10 * * ?	        	Fire at 10:15 AM every day
0 15 10 * * ? *	        	Fire at 10:15 AM every day
0 15 10 * * ? 2005	    	Fire at 10:15 AM every day during the year 2005
0 * 14 * * ?	        	Fire every minute starting at 2:00 PM and ending at 2:59 PM, every day
0 0/5 14 * * ?	        	Fire every 5 minutes starting at 2:00 PM and ending at 2:55 PM, every day
0 0/5 14,18 * * ?	    	Fire every 5 minutes starting at 2:00 PM and ending at 2:55 PM, AND fire every 5 minutes starting at 6:00 PM and ending at 6:55 PM, every day
0 0-5 14 * * ?	        	Fire every minute starting at 2:00 PM and ending at 2:05 PM, every day
0 10,44 14 ? 3 WED	    	Fire at 2:10 PM and at 2:44 PM every Wednesday in the month of March
0 15 10 ? * MON-FRI	    	Fire at 10:15 AM every Monday, Tuesday, Wednesday, Thursday and Friday
0 15 10 15 * ?	        	Fire at 10:15 AM on the 15th day of every month
0 15 10 L * ?	        	Fire at 10:15 AM on the last day of every month
0 15 10 ? * 6L	        	Fire at 10:15 AM on the last Friday of every month
0 15 10 ? * 6L	        	Fire at 10:15 AM on the last Friday of every month
0 15 10 ? * 6L 2002-2005	Fire at 10:15 AM on every last friday of every month during the years 2002, 2003, 2004, and 2005
0 15 10 ? * 6#3	        	Fire at 10:15 AM on the third Friday of every month
0 0 12 1/5 * ?	        	Fire at 12 PM (noon) every 5 days every month, starting on the first day of the month
0 11 11 11 11 ?	        	Fire every November 11 at 11:11 AM


Wireless

一致性哈希算法
https://github.com/icloudkit/coding-interview-university/blob/master/translations/README-cn.md

area

nationality
province
city

monitor
overview

developer


yiwan.net

for /l %i in (1,1,99) do @type nul>%i.pdf

-------------------------------------------------------------------------------------------
$('body').append("<input type=\"text\" id=\"pdf-view\" />");

var listItem = "";
var i = 1;

self.setInterval(function(){
    listItem = $('#outer_page_' + i).html();
    // console.log(listItem);
	$('#pdf-view').val($('#pdf-view').val() + listItem);
    $('#nextPageButton').click();
    i++;
}, 1000);



专业、简单、无限可能

驰而不息

生命不息 数据不止
计算和数据生生不息
让数据栩栩如生

坚持不懈，永不停息

智慧未来
生态系统

传递 通信

发现、分享、创造\缔造生活之美

每个人都有自己的生活
每个人都会有梦想，有大梦想，有小梦想

如赛场
未分级

网络
点 线 面

连接、映射、化简、过虑、分发、转换、编码、解码、路由、编排/重排、适配、变换、聚合、包装、清除、扩充、分派、分解

心满意足


您每个夜晚都会休息
但您的梦想却依然清醒
因为抱负从不歇息
激情从不歇息
目标从不歇息
希望从不歇息
机会从不歇息
这个世界也从不歇息
所以 我们不分国界
不分昼夜
为您全力实现每个梦想
所以 花旗从不歇息

Every night you sleep
But your dreams are wide awake because
Ambitions never sleep
Aspirations never sleep
Goals never sleep
Hopes never sleep
Opportunities never sleep
The world never sleeps
That's why we work around the world
That's why we work around the clock
To turn dreams into realities
That's why Citi never sleeps


人的等级，这种等级在人获得物质上的自由之前是以财富来划分的，而人在获得了物质上的自由后、获得精神上的自由之前是以智力来划分的，而人获得精神上的自由之后是以所抵达的审美的境界来划分的，最后以是否完成了“自我现实”来划分。每一个人追求的最终极的目标都是“自我实现”，可以是信仰的方式，也可以是非信仰的方式，总之人最终获得了诗意的栖居，天人合一。


Sketch

Java内存对象的逃逸分析



七大基础学科依次为数学、逻辑学、天文学和天体物理学、地球科学和空间科学、物理学、化学、生命科学

数学

数学是研究数量、结构、变化以及空间模型等概念的一门学科。透过抽象化和逻辑推理的使用，由计数、计算、量度和对物体形状及运动的观察中产生。数学家们拓展这些概念，为了公式化新的猜想以及从合适选定的公理及定义中建立起严谨推导出的真理。
数学又包括：几何学、初等数学、高等数学、模糊数学、代数等。

逻辑学
旧称“论理学”、“理则学”、“名学”、“辩学”。关于思维形式及其规律的学科，由亚里士多德创立。由德国古典哲学家们创立的逻辑学使逻辑学进入了一个新的领域。黑格尔把思维形式的发展与人的认识的各个阶段紧密结合起来进行研究，这些思维形式彼此联系、相互转化，又具有新的意义。

天文学
天文学(Astronomy)是研究宇宙空间天体、宇宙的结构和发展的学科。内容包括天体的构造、性质和运行规律等。主要通过观测天体发射到地球的辐射，发现并测量它们的位置、探索它们的运动规律、研究它们的物理性质、化学组成、内部结构、能量来源及其演化规律。天文学是一门古老的科学，自有人类文明史以来，天文学就有重要的地位。

天体物理学
天体物理学是应用物理学的技术、方法和理论，研究天体的形态、结构、化学组成、物理状态和演化规律的天文学分支学科。

地球科学
地球科学 是以地球系统(包括大气圈、水圈、岩石圈、生物圈和日地空间)的过程与变化及其相互作用为研究对象的基础学科。主要包括地理学(含土壤学与遥感)、地质学、地球物理学、地球化学、大气科学、海洋科学和空间物理学j以及新的交叉学科（地球系统科学、地球信息科学）等分支学科。地球科学是一个大题目，纵横几万里，上下数亿年，几乎辐射到自然科学的其他各个领域。对地球的认识同世界各民族的起源、历史、文化乃至这个世界文明的进展，都是紧密联系在一起的。

空间科学
空间科学（space science）是指利用航天器研究发生在日地空间、行星际空间及至整个宇宙空间的物理、天文、化学及生命等自然现象及其规律的科学。空间科学以航天技术为基础，包括空间飞行、空间探测和空间开发等几个方面。它不仅能揭示宇宙奥秘，而且也给人类带来巨大的利益。

化学
化学（Chemistry）是研究物质的组成、结构、性质、以及变化规律的科学。世界是由物质组成的，化学则是人类用以认识和改造物质世界的主要方法和手段之一，它是一门历史悠久而又富有活力的学科，它的成就是社会文明的重要标志。

生命科学
生命科学是研究生命现象、生命活动的本质、特征和发生、发展规律，以及各种生物之间和生物与环境之间相互关系的科学。用于有效地控制生命活动，能动地改造生物界，造福人类生命科学与人类生存、人民健康、经济建设和社会发展有着密切关系，是当今在全球范围内最受关注的基础自然科学。



如何判断VPS是基于哪种虚拟技术？
Xen、OpenVZ、Xen HVM、KVM还是VMware

对于VPS新手来说，怕被无良的奸商给忽悠，下的Xen的却给的OpenVZ的，如何来判断自己买的VPS是那种虚拟技术的，下面VPS侦探整理一些常见的方法。
1、通过系统上的相关目录或文件判断
执行：ls /proc/ ，一般Xen的VPS，/proc目录下面会有xen的目录，openvz的会有vz目录。
2、执行：free -m 看内存，openvz的没有swap，当然也有xen的没有swap，但是xen的是可以加的，openvz不行。KVM是全虚拟化也是可以自己添加swap的。
3、执行：uname -a  有些xen的VPS里面会显示有xen。
4、执行：ifconfig 查看网卡，openvz的一般都是venet0:* ，xen、kvm的一般都是eth*。
5、通过VPS控制面板查看，像SolusVM、vePortal控制面板上都显示虚拟技术。
6、使用专门的软件：virt-what ，virt-what是一个判断当前环境所使用的虚拟技术的脚本，常见的虚拟技术基本上都能正常识别出来。

可以执行如下命令安装(需要安装好gcc、make)：

wget http://people.redhat.com/~rjones/virt-what/files/virt-what-1.15.tar.gz
tar zxvf virt-what-1.15.tar.gz
cd virt-what-1.15/
./configure
make && make install

再运行 virt-what ，脚本就会判断出当前环境所使用的虚拟技术，VPS侦探用手头上的VPS测试成功率还是比较高的。

腾讯云
[root@VM_223_239_centos ~]# virt-what
kvm

阿里云
[root@iZ285h4y5m0Z ~]# virt-what
xen
xen-hvm


LXC：linux Container

https://www.packtpub.com/

进程间通信IPC Inter-Process Communication
由于内存管理的一些机制，导致两个进程间并不能直接的进行通信(在独立的用户空间),因此我们需要利用一些介质来完成两个进程之间的通信。以下是常用的进程间通信方式。
# 管道(pipe)：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
# 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
# 信号量(semophore) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
# 消息队列(message queue) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
# 信号 (sinal) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
# 共享内存(shared memory) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
# 套接字(socket) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

要么单机的STM，分布式锁，数据库锁


一致性算法
Paxos Raft
随机抽样（RANSAC Random Sample Consensus）
http://en.wikipedia.org/wiki/ransac

一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一
致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。


企业集成模式:设计、构建及部署消息传递解决方案
http://www.enterpriseintegrationpatterns.com/




cPanel

linux container(LXC)


okhttp

JAVA 9
Jigsaw
REPL
JSON API
JIT(Just-in-time)
http://javamoney.github.io/

API Gateway
流量控制
熔断技术
微服务编排和调度
Monitor 服务健康度和质量
灾难备份
自动化性能伸缩
多租户和云化服务
资源调度
自动化运维

SOA服务化，消息中间件，远程调用中间件，缓存中间件，服务调度，监控，部署，网关



{
    "name": "some-app",
    "description": "description",
    "namespace": "default",
    "env": {
        "name": "local",
        "description": "the nodes of local environments",
        "nodes": [],
        "storages": []
    },
    "healthcheck_retry_times": 10,
    "healthcheck_interval": 10,
    "stack_provision_timeout": 1200000000000,
    "stack_destroy_timeout": 1200000000000,
    "stack_update_timeout": 1200000000000,
    "stack_scale_timeout": 1200000000000,
    "env_variables": [
        {
            "name": "INFRASTRUCTURE_PROVIDER",
            "value": "aws"
        },
        {
            "name": "SCRIPT_LOG_LEVEL",
            "value": "WARNING"
        }
    ],

   "deployments": [
        {
            "name": "backend-server",
            "image": "172.31.13.51/megaese/tomcat-server",
            "image_version": "1.8",
            "type": "Stateless",
            "description": "the backend-server component deployment information",
            "instance_count": 3,
            "require_resource": {
                "cpu": "300m",
                "memory": "512Mi"
            },
            "limit_resource": {
                "cpu": "500m",
                "memory": "1Gi"
            },
            "storage_mounts": [],
            "coloring_nodes": [
                "ip-172-31-10-103",
                "ip-172-31-9-252",
                "ip-172-31-14-200"
            ],
            "configurations": [
                "{\n\"httpPort\": 9527,\n\"stage\": \"test\"\n}"
            ],
            "initial_delay_seconds": 90,
            "healthcheck_retry_times": 30,
            "named_ports": [
                {
                    "name": "httpPort",
                    "port": 8080,
                    "is_host_port": false
                }
            ],
            "is_node_port": false,
            "node_port_policy": "default",
            "env_variables": []
        },

        {
            "name": "fontend-server",
            "image": "172.31.13.51/megaease/reactjs-web",
            "image_version": "1.8",
            "type": "Stateless",
            "description": "the reactjs-web component deployment information ",
            "instance_count": 1,
            "require_resource": {
                "cpu": "200m",
                "memory": "128Mi"
            },
            "limit_resource": {
                "cpu": "500m",
                "memory": "1Gi"
            },
            "storage_mounts": [],
            "coloring_nodes": [
                "ip-172-31-2-1"
            ],
            "configurations": [
                "{\n\"httpPort\": 8080,\n\"stage\": \"test\"\n}"
            ],
            "initial_delay_seconds": 60,
            "named_ports": [
                {
                    "name": "httpPort",
                    "port": 80,
                    "is_host_port": true
                }
            ],
            "is_node_port": true,
            "node_port_policy": "default",
            "env_variables": []
        }
    ],
    "healthchecker_image": "172.31.13.51/megaease/cmdagent",
    "healthchecker_image_version": "1.1"
}


CSS3 Grid Layout
Service Worker
HTML5 Web Worker
WebAssembly


JVMTI（Java Virtual Machine Tool Interface）
java.lang.instrument


RandomAccessFile


// ASYNC asynchronous
function PDFSign(params, fun) {
    console.log('1-----------------');
    fun();
}

function PDFSignFun(params) {
    var isFinish = false;
    PDFSign(params, function(){
        // isFinish = true;
        console.log('2-----------------');
    })
    while(!isFinish) {}
}


RBAC 基于角色的访问控制 (Role-Based Access Control)
权限系统只有适合的，没有通用的，如果要通用的就基于RBAC就可以了，权限系统涉及的问题太多，效率也是问题，权限的继承也是问题，所以要根据自己的项目做才好


扁平化的权限设计

BDD
Behavior-driven development (https://en.wikipedia.org/wiki/Behavior-driven_development)

Azur Corporation
Sales Promotion Design.pdf

Microservices vs. Monolithic

libevent

Scratch
Sketch

Cocos2D
Unity3D
AndEngine
libGDX

SDN，软件定义网络(Software Defined Network, SDN )，是Emulex网络一种新型网络创新架构，是网络虚拟化的一种实现方式，其核心技术OpenFlow通过将网络设备控制面与数据面分离开来，从而实现了网络流量的灵活控制，使网络作为管道变得更加智能。
NFV，即网络功能虚拟化，Network Function Virtualization

CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术

MVCC Multi-Version Concurrency Control 多版本并发控制

REPEATABLE READ
READ COMMITED
READ UNCOMMITED
SERIABLABLE

Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
Read committed (读已提交)：可避免脏读的发生。
Read uncommitted (读未提交)：最低级别，任何情况都无法保证。


事务处理 概念与技术 Jim Gray
transaction processing concepts and techniques pdf

Enterprise Integration Patterns : Designing, Building, and Deploying Messaging Solutions

第四范式：数据密集的科学发现

The Manager’s Path 作者 Camille Fournier
感知与响应 作者 Jeff Gothelf 和Joshua Seiden
Doing It - Management 3.0 Experiences 作者 Ralph van Roosmalen
Scaling Lean 作者 Ash Maurya
It's All Upside Down 作者 Paul McMahon

E-Science

Ken Thompson
Dennis Ritchie
Rob Pike
RISC之父John Cocke
Edsger Wybe Dijkstra


OLTP OLAT
TPC-A
TPC-B
TPC-C

ACID，指数据库事务正确执行的四个基本要素的缩写。包含:原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)。一个支持事务(Transaction)的数据库，必需要具有这四种特性，否则在事务过程(Transaction processing)当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。

CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency(一致性)、 Availability(可用性)、Partition tolerance(分区容错性)，三者不可得兼。

分布式系统的CAP理论:理论首先把分布式系统中的三个特性进行了如下归纳:
一致性(C):在分布式系统中的所有数据备份，在同一时刻是否同样的值。(等同于所有节点访问同一份最新的数据副本)
可用性(A):在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。(对数据更新具备高可用性)
分区容忍性(P):以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

CQRS
命令查询职责分离（CQRS，Command Query Responsibility Segregation）是一种应用架构模式，它会将应用分为两部分：查询部分（查看模型）和命令部分（写入模型）。每一部分都负责处理特定的操作集——分别也就是读取类型和写入类型。CQRS概念最初是由Greg Young提出和积极倡导的。它是CQS（命令-查询分离）理念的自然延伸，CQS理念由Bertrand Meyers提出，主张将方法分为命令和查询。CQRS使用了相同的原则，不过将其扩大到了整个系统中。


业务流程管理（Business Process Management，BPM）
业务流程改进（BPI Business process improvement,流程改进)自从流程再造思想诞生以来，对于"再造"的理解就存在不同的看法。且不说由Reengineering 衍生而来的Redesign(再设计)、Reorganization(再组织)、Reposition(再定位)、Revitalization(再生)等分支观点，以及由此激发的人们Re-everything(再造一切)的激情。单是能用来矫正或丰富BPR(Business process reengineering,流程再造)的定义的就有BPI(Business process improvement,流程改进)、BMR(Business model reengineering,生意模式再造)、BPM(Business process management,流程管理)和IPR(Industrial process reengineering)。
业务流程重组(Business Process Reengineering，BPR)最早由美国的Michael Hammer 和James Champy提出，在20世纪90年代达到了全盛的一种管理思想。强调以业务流程为改造对象和中心、以关心客户的需求和满意度为目标、对现有的业务流程进行根本的再思考和彻底的再设计，利用先进的制造技术、信息技术以及现代的管理手段、最大限度地实现技术上的功能集成和管理上的职能集成，以打破传统的职能型组织结构，建立全新的过程型组织结构，从而实现企业经营在成本、质量、服务和速度等方面的戏剧性的改善。

工作流管理、EAI、流程自动化、流程集成、流程建模、流程优化

钛合金
