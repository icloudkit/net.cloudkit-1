template engine
timing task

passport
dashboard


https://fancy.com/hongquanli
infinite
thymeleaf

System.setProperty("spring.profiles.active", "production");

MQTT

Kotlin in Action
Kotlin for Android Developers
https://light.hs.net/portal/not-support.html


lightart/github

encyclopedia
Scalable
Resources

快速清空文件内容：
　　$ : > filename #其中的 : 是一个占位符, 不产生任何输出.
　　$ > filename
　　$ echo '' > filename
　　$ echo /dev/null > filename
　　$ echo > filename
　　$ cat /dev/null > filename


泛化、继承、实现、依赖、关联、聚合、组合
单例 多例 静态 线程安全

Behavior
Event
Action
Command

Service

Request
Response
Context
Data

Content-Type: MIME
.xml text/xml
.json text/json

SearchCriteria

attachment
encoding
version

Backup
Data
Temp
Video
Attachment
Config
Image
Favorite
Docs

prototype

singleton

Resources
Representation
State Transfer

ConfigurableBeanFactory
AbstractBeanFactory

Search criteria/command


support

// Request
{
    access_key:'',
    source_address:'C0-3F-D5-E5-20-51',
    mac:'',
    compress_algorithm:''
    signature_algorithm:''
    encrypt_algorithm:'',
    signature:'',
    version:'1.0',
    service:'Behavior, Event, Action, Command',
    content_type:'text/json',
    encoding:'UTF-8',
    timestamp:'1445950906202',
    description:'',
    arguments:{
        'props':{

        }
    },
    data:{
        offset:'',
        limit:'',
        content:''
    }
}

// Response
{
    path:'',
    service:'',
    status:'',
    message:'',
    error:'',
    timestamp:'1445950906202',
    version:'1.0',
    content_type:'text/json',
    encoding:'UTF-8',
    description:'',
    arguments:{
        'props':{

        }
    },
    data:{
        page_number:'Behavior, Event, Action, Command',
        page_size:20,
        total_elements:'',
        total_pages:'',
        is_first:true,
        is_last:false,
        has_next:'',
        has_previous:'',
        content:{
            // ......
        }
    }
}


target

{
    “userKey”: “975bf42bdf837a1e43508a9bf6340420”,
    “sourceAddress”: “120.2.6.5”,
    “mac”: “C0-3F-D5-E5-20-51”,
    “compressAlgorithm”: “gzip”,
    “signatureAlgorithm”: “”,
    “encryptAlgorithm”: “”,
    “signature”: “”,
    “encoding”: “UTF-8”,
    “version”: “1.0”,
    “timestamp”: “1445950906202”,
    “description”: “”,
    “arguments”: {
        “props”: {
            “key”: “value”,
            ……
        }
    }
}

{
    “responseCode”: “”,
    “responseMessage”: “”,
    “compressAlgorithm”: “gzip”,
    “signatureAlgorithm”: “”,
    “encryptAlgorithm”: “”,
    “serviceResponseCode”: “”,
    “serviceResponseMessage”: “”,
    “exceptionDetail”: “”,
    “encoding”: “UTF-8”,
    “version”: “1.0”,
    “timestamp”: “1445950906202”,
    “description”: “”,
    “arguments”: {
        “props”: {
            “key”: “value”,
            ……
        }
    }
}






企业各职位英文缩写：
GM(General Manager)总经理
VP(Vice President)副总裁
FVP(First Vice President)第一副总裁
AVP(Assistant Vice President)副总裁助理
CEO(Chief Executive Officer)首席执行官，类似总经理、总裁，是企业的法人代表。
COO(Chief Operations Officer)首席运营官，类似常务总经理
CFO(Chief Financial Officer)首席财务官，类似财务总经理
CIO(Chief Information Officer)首席信息官，主管企业信息的收集和发布
CTO(Chief technology officer)首席技术官 类似总工程师
HRD(Human Resource Director)人力资源总监
OD(Operations Director)运营总监
MD(Marketing Director)市场总监
OM(Operations Manager)运作经理
PM(Production Manager)生产经理 (Product Manager)产品经理

其他：
CAO: Art 艺术总监
CBO: Business 商务总监
CCO: Content 内容总监
CDO: Development 开发总监
CGO: Gonverment 政府关系
CHO: Human resource 人事总监
CJO: Jet 把营运指标都加一个或多个零使公司市值像火箭般上升的人
CKO: Knowledge 知识总监
CLO: Labour 工会主席
CMO: Marketing 市场总监
CNO: Negotiation 首席谈判代表CPO: Public relation 公关总监
CQO: Quality control 质控总监
CRO: Research 研究总监
CSO: Sales 销售总监
CUO: User 客户总监
CVO: Valuation 评估总监
CWO: Women 妇联主席
CXO: 什么都可以管的不管部部长
CYO: Yes 什么都点头的老好人
CZO: 现在排最后，等待接班的太子

*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*
*******************************************
            ╭╮　　　　　　　╭╮　　
          　││　　　　　　　││　　
          ╭┴┴———————┴┴╮
          │　　　　　　　　　　　│　　　
          │　　　　　　　　　　　│　　　
          │　●　　　　　　　●　│
          │○　　╰┬┬┬╯　　○│
          │　　　　╰—╯　　　　│　
          ╰——┬Ｏ———Ｏ┬——╯
　 　           ╭╮　　　　╭╮　　　　
　            　╰┴————┴╯
  ╭══╮
╭╯ΘΘ ║
╰⊙═⊙╯。oо○Thanks & BestRegards  *^o^*

SwarmKit

http://java-design-patterns.com/
https://github.com/hoohack/DesignPattern

MQTT

http://iot.eclipse.org/projects


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Sign up
Sign in/Log in
Sign out

console/workbench/dashboard/main

merchant
  products
  orders
  insights
  promote
    coupons
      Add New Coupon
  campaigns
    Create Campaign
  settings
    account
      The Basics
    general
      Brand Image
    shipping/preferences
      Shipping Rules
    policy
      Policies
    payment
    storefront
      Storefront
    notifications
      Notifications
  faq
    about/merchants/resources/faq



  cart
  settings
    profile
      Edit Profile
      Deactivate my account
    preferences
      Edit Preferences
    password
    notifications
      Notifications
    accounts
      Connected Accounts
    purchases
      Orders
    cards
      Payment Methods
    shipping
      Shipping Addresses
    credits
      credit
      referrals
      giftcards


    lists
    wishlist
    likes

report


connect?source=qq

topic
article

commodity/product/goods
goods,commodity,product,merchandise,wares这些名词都可表示“商品,货物”之意.
products是产品
goods是物品
commodity是日用品
merchandise是货物
详细点就是：
goods一般生活或商业用词,指销售或购入的商品.Goods 货物!
commodity作“商品”解时系经济学名词,也可指日用品.
product一般指工业产品,也可泛指各种各样的产品.
merchandise正式用词,指商业上销售或商家拥有货物的总称.
wares 指上市待卖的商品或货物.多用复数形式.
merchandise 商品,泛指商品,不特指某一商品

order

shopping cart


市场价 retail price
加盟价 franchise price
会员价 member price
商品单位 product unit
数量 amount
编号 product ID
单位 unit
类别 category
产品介绍 product description

对不起，您还没有登陆 sorry, you didn't log in yet.
添加购物 add to shopping cart
商品已经成功添加您的购物车 product added to your shopping cart
商品数量修改成功 product amount modified successfully
购物车被清空 your shopping is emptied (Your shopping cart is empty)
删除成功 deleted successfully

您从何处知道本网站  Where you heard our site from

递交 submit
重写 reset

你的数据添加成功 your information added successfully
你的数据添加失败 add information failed

申请会员成功 membership successfully registered
申请失败 membership apply failed










Payment method

Order summary

Choose a shipping address
Review order




Share
Share this with friends
Lists
Save this to your profile



活锁

------------------------------------------------------------------------------------------------------------------------
解决Tomcat catalina.out 不断成长导致档案过大的问题
Tomcat的网站上的说法http://wiki.apache.org/tomcat/FAQ/Logging#Q6：
System.out 和 System.err 都被打印到 catalina.out。
catalina.out 不会 rotate。
如果您使用了 logging 机制，就不会有任何东西被写到标准输出了，所以这应该不会是个问题。
可是实际上发现，虽然有设了log4j之类的 logging 机制，但写程序的人如果还是写成System.out.println()或是遇到exception时都来个e.printStackTrace()，这些输出最后还是通通送到catalina.out去了。日子久了，这个档案还是会日渐变大起来，如果没有加以管理最后就会长大成好几GB的庞然大物。（这时千万不要再用vi去开它了。）
网络上找了一下，针对在Linux环境下执行Tomcat的部份，发现有个不错的工具软件cronolog可以协助Web Server之类的做 log 檔的 rotate，详细的运作原理可能大家得自己去这个网站上查，我的认知大致如下：
Tomcat先把输出写到 console(标准输出) 然后透过 pipe (|) 转为 cronolog 的输入，由cronolog针对一个事先给定的文件名的命名规则，去过滤数据，定期关闭旧文件，然后再开启新档。如果我们将文件名的命名规则设为catalina.out.%Y-%m-%d，就可以做到每天开一个新的catalina.out.yyyy-mm-dd的档案了。
以下是简单的过程说明：
1.安装cronolog
2.修改catalina.sh
3.重新启动Tomcat

1 安装cronolog
wget http://cronolog.org/download/cronolog-1.6.2.tar.gz
tar zxvf cronolog-1.6.2.tar.gz
cd cronolog-1.6.2
./configure
make
make install

用which cronolog可以查到安装的路径，默认应该是/usr/local/sbin/cronolog，这个路径待会在修改catalina.sh时会用到。
2 修改catalina.sh
以Tomcat 6.0.24的版本为例
2.1 第一步
将
if [ -z "$CATALINA_OUT" ] ; then
CATALINA_OUT="$CATALINA_BASE"/logs/catalina.out
fi
修改为
if [ -z "$CATALINA_OUT" ] ; then
CATALINA_OUT="$CATALINA_BASE"/logs/catalina.out.%Y-%m-%d
fi
2.2 第二步
将
touch "$CATALINA_OUT"
改为
#touch "$CATALINA_OUT"
2.3 第三步
将
org.apache.catalina.startup.Bootstrap "$@" start /
>> "$CATALINA_OUT" 2>&1 &
修改为
org.apache.catalina.startup.Bootstrap "$@" start 2>&1 /
| /usr/local/sbin/cronolog "$CATALINA_OUT" >> /dev/null &
2.4 重新启动Tomcat
service tomcat restart
可以在Tomcat的logs目录底下找到以系统日期为结尾的catalina.out.yyyy-mm-dd的档案，这样子就成功了。
后续就是持续观察看看是不是每天都有产生一个新的catalina.out.yyyy-mm-dd档案。然后再安排定期删除这些较旧的log檔即可。


Linux下的tomcat产生的日志文件不象windows下的按时间时间和大小来处理，
尽管也生成了日志文件catalina.2009-0x-0x.log类型的文件，但是其中的catalina.out文件依然增大；它为啥在增大，为啥在增大，原因我就不探究了。

Tomcat的官方文档，由于是外文，偶还没有看明白di；
http://tomcat.apache.org/tomcat-6.0-doc/logging.html
据说是修改某些配置可以实现，希望高人指点，给个官方的解决方案；
老是增大也不是办法，还是想其他办法搞定它为好：
方法1—分割流
使用cronolog工具切分Tomcat的catalina.out日志文件
cronolog一个对日志切分的小工具，其主页在http://cronolog.org/，我们也可以用它来切分Apache的日志。
具体的方法，您可以去google之，这个方法占网络搜索结果的主流；
方法2—脚本流
事情终究不过是个大文件处理的问题，强大的bash来搞定；
使用cron每天来备份当前的catalina.out，然后清空他的内容；
参考脚本如下：
#!/bin/sh
y=`date "+%Y"`
m=`date "+%m"`
d=`date "+%d"`
cd /PATH /tomcat/logs
cp catalina.out catalina.out.$y$m$d
echo > catalina.out
exit
注意linux系统的cron服务是否启动，是否正常工作，还有脚本的存放路径（原因暂保密）

方法3—猥琐流
打开bin目录下的catalina.sh文件，终究不过是个bash文件，
查找一下，catalina.out总共出现三次；
部分截图：
shift
touch "$CATALINA_BASE"/logs/catalina.out
if [ "$1" = "-security" ] ; then
    echo "Using Security Manager"
    shift
    "$_RUNJAVA" $JAVA_OPTS "$LOGGING_CONFIG" $CATALINA_OPTS \
      -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \
      -Djava.security.manager \
      -Djava.security.policy=="$CATALINA_BASE"/conf/catalina.policy \
      -Dcatalina.base="$CATALINA_BASE" \
      -Dcatalina.home="$CATALINA_HOME" \
      -Djava.io.tmpdir="$CATALINA_TMPDIR" \
      org.apache.catalina.startup.Bootstrap "$@" start \
      >> "$CATALINA_BASE"/logs/catalina.out 2>&1 &
      if [ ! -z "$CATALINA_PID" ]; then
        echo $! > $CATALINA_PID
      fi
else
    "$_RUNJAVA" $JAVA_OPTS "$LOGGING_CONFIG" $CATALINA_OPTS \
      -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \
      -Dcatalina.base="$CATALINA_BASE" \
      -Dcatalina.home="$CATALINA_HOME" \
      -Djava.io.tmpdir="$CATALINA_TMPDIR" \
      org.apache.catalina.startup.Bootstrap "$@" start \
      >> "$CATALINA_BASE"/logs/catalina.out 2>&1 &
个人觉得也就是这里是写catalina.out文件的；让他写到一个其他的空设备如何？
修改前注意原文件的catalina.sh的备份哟~！！
修改以上代码中的
>> "$CATALINA_BASE"/logs/catalina.out 2>&1 &
为
>> /dev/null 2>&1 &
保存，然后启动tomcat，目前这个 catalina.out一直是空的了。
这个方法是偶自己想到的，个人认为比较勇敢，目前还没有在生产环境测试过。虚拟机测试是通过的。

方法4—人流
这个方法其实就是linux系统管理员手工去删除，人工操作，简称“人流”；
删除之前最好停止tomcat的服务；
------------------------------------------------------------------------------------------------------------------------


Paxos和Raft
Consensus

Nginx（或Haproxy） +keepalived

Keepalived
ZooKeeper

http://thesecretlivesofdata.com/raft/
CAP原理和BASE思想
http://www.jdon.com/37625
分布式系统Paxos算法
http://www.jdon.com/artichect/paxos.html

2PC到3PC到Paxos到Raft到ISR
https://segmentfault.com/a/1190000004474543

射线光学理论



<servlet>
    <servlet-name>chapter2</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-servlet-config.xml</param-value>
    </init-param>
</servlet>


RabbitMq、ActiveMq、ZeroMq、kafka
http://flume.apache.org/
https://github.com/facebookarchive/scribe
http://chukwa.apache.org/
http://flink.apache.org/
http://kafka.apache.org/

jackson
com.fasterxml.jackson
http://community.jaspersoft.com/project/jasperreports-library
https://github.com/flexpaper/pdf2json
https://flowpaper.com/download/
https://github.com/flexpaper/flexpaper

Libxml
http://xmlsoft.org/

lua
http://www.lua.org/

libpng
http://www.libpng.org/

json
http://www.json.org/json-zh.html


XML、JSON、ProtocolBuffer、Lua
http://lua-users.org/wiki/JsonModules



Zookeeper在集群负载均衡中的应用
Zookeeper本身是不提供负载均衡的策略,需要自己来实现，所以这里确切的说，是在负载均衡中应用到了Zookeeper做集群的协调。
对于HTTP请求的负载均衡，成熟的解决方案是Nginx（或Haproxy） +keepalived。其中Niginx负责代理HTTP请求，通过某种均衡策略访问集群中的服务器，keepalived负责检测集群中的服务器运行情况（有故障的机器移除，机器恢复工作后重新加入）
而对于TCP层的负载均衡，比如用Apache Mina做的网络通信应用，上面那种方案明显不适合，因为网络通信客户端和服务端要保持长连接
所以要针对这种长连接做负载均衡，一般都是基于连接数这种均衡策略，也就是在第一次连接时，分配服务器IP时，取当前连接数最少的那台
集群中有几台服务器处于运行状态，每一台服务器当前连接的客户数量，最大连接数量，等等这些信息需要记录起来，然后每次做负载均衡时根据这些信息来做分配，一般首先想到的是把这些信息存放在数据库里
简单的做法就是服务器启动时，把数据库里相应的状态改为运行，有客户连接或断开时，把连接数做加数或减数运算。
当服务器关闭时，问题就来了：
1、服务器关闭，可能数据源也已经被关闭，没法操作数据库，该机器在数据库里一直处于运行状态
2、服务器宕机，这种问题就很致命，这是连关闭的程序都没有执行，更不用说能操作数据库了
解决的方式就是用Zookeeper保存服务器的连接信息
1、当服务器启动时，往Zookeeper的节点里写入数据（节点类型是临时节点）
2、当服务器关闭时，从Zookeeper移除相应的节点数据
3、当服务器宕机，Zookeeper因为没有检测到心跳，自动把该节点移除，并通知其他服务器，其他服务器得知该机器已宕机，在分配连接时，不会分配到这台机器上，这点也是标题说的在负载均衡中用到Zookeeper的原因。
对比了一下保存在数据库那种方式，Zookeeper其实就是一个具有通知功能的数据库，也就是它底下节点数据有变化时，会通知它的所有客户端（这里的客户端指的连接到Zookeeper的服务器）。


HA和负载均衡的区别
1、HA（High Available）：主要解决可靠性问题，设备、部件的互备等，通过技术也可以实现部分的流量负载分担功能。
　常见的有服务器的HA，俗称双机热备；
　网络的HSRP/vrrp/glp，以及各厂商的私有技术，像cisco防火墙的failover，juniper防火墙的nsrp等等。
2、负载均衡：可分为网络层面和应用层面
　网络层面一般可能使用端口聚合、多路径等技术，主要在网络层面实现流量负载均衡。
　应用层面的负载均衡，主要厂商有F5、radware、cisco等等，通过专用的负载均衡设备实现基于不同应用类型的负载均衡。
两个就不是一回事，不可相比，一个用于设备冗灾，一个用于流量分分担

HA
http://blog.csdn.net/e421083458/article/details/30092795
http://www.cnblogs.com/holbrook/archive/2012/10/25/2738475.html
https://yq.aliyun.com/articles/24155
http://blog.sina.com.cn/s/blog_4e424e2101007rie.html

OpenVPN
OpenGl
WebGl


http://www.firewalld.org/documentation/howto/open-a-port-or-service.html


x        删除当前光标下的字符
dw       删除光标之后的单词剩余部分。
d$       删除光标之后的该行剩余部分。
dd       删除当前行。

c        功能和d相同，区别在于完成删除操作后进入INSERT MODE
cc       也是删除当前行，然后进入INSERT MODE
删除每行第一个字符    :%s/^.//g


同步时间
ntpdate 172.16.0.1


证明（递归）、算法（递归）、语言（λ演算[10]）、操作系统（指针）、编译器（λ演算）


服务发现 zookeeper ,consul ,etcd
zipkin为分布式链路调用监控系统，聚合各业务系统调用延迟数据，达到链路调用监控跟踪。

netflix
zuul用来提供动态路由、监控、授权、安全、调度等等的边缘服务(edge service)。
feign是一个类似retrofit进行http调用框架，Feign makes writing Java http clients easier 使得编写http client代码更加简单。
eureka 用以服务发现、服务注册，比较流行的有consul。
ribbon用以实现负载均衡；实现软负载均衡，核心有三点：
1.服务发现，发现依赖服务的列表
2.服务选择规则，在多个服务中如何选择一个有效服务
3.服务监听，检测失效的服务，高效剔除失效服务
turbine是聚合服务器发送事件流数据的一个工具，hystrix的监控中，只能监控单个节点，实际生产中都为集群，因此可以通过turbine来监控集群下hystrix的metrics情况，通过eureka来发现hystrix服务。
hystrix通过服务隔离、熔断(也可以称为断路)、降级等手段控制依赖服务的延迟与失败。

http://www.ruanyifeng.com/


两种I/O多路复用模式：Reactor和Proactor

RxJava: Reactive Extensions for the JVM
Querydsl
https://ebean-orm.github.io/
http://ignite.apache.org/
https://www.consul.io


 MATLAB和Mathematica、Maple并称为三大数学软件

 布隆过滤器(Bloom Filter)

SNMP

BPEL：全称为Business Process Execution Language,即业务流程执行语言，是一种使用XML编写的编程语言。用于自动化业务流程，也曾经被称作WSBPEL和 BPEL4WS。广泛使用于Web服务相关的项目开发中，优点为具有可移植性和有效保护了投资。


Spring Security

under active development.
has much more community support.
Spring security has extensions providing support for both Oauth and kerberos and SAML.

Shiro

Does not support saml or Oauth.
Makes no mention of supporting before and after security policies.
Active development seems limited, the website still contains erroneous information.


DevOps


领域通用语言（UBIQUITOUS LANGUAGE）
UnitOfWork
Factory
Repository
Event Sourcing
Aggregate，Aggregate Root
Domain Service
Value Object
Entity

User Interface
Application
Domain
Infrastructure

事务
池化
虚拟
存储
协议
算法


一,事务的4个基本特征
Atomic（原子性）：
事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。
Consistency（一致性）：
只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。
Isolation（隔离性）：
事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。
Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。
二,为什么需要对事务并发控制
如果不对事务进行并发控制，我们看看数据库并发操作是会有那些异常情形
Lost update：
两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。
Dirty Reads：
一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚。
Non-repeatable Reads： 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。
Second lost updates problem： 无法重复读取的特例。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。
Phantom Reads：
事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。
三, 数据库的隔离级别
为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（Oracle和SQLSERER对标准隔离级别有不同的实现 ）
Read Uncommitted：
直译就是"读未提交",意思就是即使一个更新语句没有提交,但是别的事务可以读到这个改变.这是很不安全的.
Read Committed：
直译就是"读提交",意思就是语句提交以后即执行了COMMIT以后别的事务就能读到这个改变.
Repeatable Read：
直译就是"可以重复读",这是说在同一个事务里面先后执行同一个查询语句的时候,得到的结果是一样的.
Serializable:
直译就是"序列化",意思是说这个事务执行的时候不允许别的事务并发执行.
四，隔离级别对并发的控制
下表是各隔离级别对各种异常的控制能力。
 	LU	DR	NRR	SLU	PR
RU	Y	Y	Y	Y	Y
RC	N	N	Y	Y	Y
RR	N	N	N	N	Y
S	N	N	N	N	N
(注：LU：丢失更新；DR：脏读；NRR：非重复读；SLU：二类丢失更新；PR：幻像读)



Hibernate占位符问题[use named parameters or JPA-style positional parameters instead.]

hibernate 4.1之后对于HQL中查询参数的占位符做了改进，如果仍然用老式的占位符会有类似如下的告警信息：

[main] WARN  [org.hibernate.hql.internal.ast.HqlSqlWalker] – [DEPRECATION] Encountered positional parameter near line 1, column 95.  Positional parameter are considered deprecated; use named parameters or JPA-style positional parameters instead.
从告警提示信息中可以看出，它建议用命名参数或者JPA占位符两中种方法来代替老的占位符查询方法。

比如老的占位符查询代码片段：
String hql = "select t from Blog t where t.site=?";
Query query = getSession().createQuery(hql);
query.setParameter(0, "micmiu.com");
方法一：改成命名参数的方式：

// 命名参数的方式
String hql2 = "select t from Blog t where t.site=:site";
Query query2 = getSession().createQuery(hql2);
query2.setParameter("site", "micmiu.com");
方法二：改成JPA占位符的方式：

// JPA占位符方式
String hql3 = "select t from Blog t where t.site=?0";
Query query3 = getSession().createQuery(hql3);
query2.setParameter(0, "micmiu.com");
其中"?"后面的"0"代表索引位置，在HQL语句中可重复出现，并不一定要从0开始，可以是任何数字，只是参数要与其对应上。
