template engine
timing task

passport
dashboard


https://fancy.com/hongquanli
infinite
thymeleaf

System.setProperty("spring.profiles.active", "production");

MQTT

Kotlin in Action
Kotlin for Android Developers
https://light.hs.net/portal/not-support.html


lightart/github

encyclopedia
Scalable
Resources

快速清空文件内容：
　　$ : > filename #其中的 : 是一个占位符, 不产生任何输出.
　　$ > filename
　　$ echo '' > filename
　　$ echo /dev/null > filename
　　$ echo > filename
　　$ cat /dev/null > filename


泛化、继承、实现、依赖、关联、聚合、组合
单例 多例 静态 线程安全

Behavior
Event
Action
Command

Service

Request
Response
Context
Data

Content-Type: MIME
.xml text/xml
.json text/json

SearchCriteria

attachment
encoding
version

Backup
Data
Temp
Video
Attachment
Config
Image
Favorite
Docs

prototype

singleton

Resources
Representation
State Transfer

ConfigurableBeanFactory
AbstractBeanFactory

Search criteria/command


support

// Request
{
    access_key:'',
    source_address:'C0-3F-D5-E5-20-51',
    mac:'',
    compress_algorithm:''
    signature_algorithm:''
    encrypt_algorithm:'',
    signature:'',
    version:'1.0',
    service:'Behavior, Event, Action, Command',
    content_type:'text/json',
    encoding:'UTF-8',
    timestamp:'1445950906202',
    description:'',
    arguments:{
        'props':{

        }
    },
    data:{
        offset:'',
        limit:'',
        content:''
    }
}

// Response
{
    path:'',
    service:'',
    status:'',
    message:'',
    error:'',
    timestamp:'1445950906202',
    version:'1.0',
    content_type:'text/json',
    encoding:'UTF-8',
    description:'',
    arguments:{
        'props':{

        }
    },
    data:{
        page_number:'Behavior, Event, Action, Command',
        page_size:20,
        total_elements:'',
        total_pages:'',
        is_first:true,
        is_last:false,
        has_next:'',
        has_previous:'',
        content:{
            // ......
        }
    }
}


target

{
    “userKey”: “975bf42bdf837a1e43508a9bf6340420”,
    “sourceAddress”: “120.2.6.5”,
    “mac”: “C0-3F-D5-E5-20-51”,
    “compressAlgorithm”: “gzip”,
    “signatureAlgorithm”: “”,
    “encryptAlgorithm”: “”,
    “signature”: “”,
    “encoding”: “UTF-8”,
    “version”: “1.0”,
    “timestamp”: “1445950906202”,
    “description”: “”,
    “arguments”: {
        “props”: {
            “key”: “value”,
            ……
        }
    }
}

{
    “responseCode”: “”,
    “responseMessage”: “”,
    “compressAlgorithm”: “gzip”,
    “signatureAlgorithm”: “”,
    “encryptAlgorithm”: “”,
    “serviceResponseCode”: “”,
    “serviceResponseMessage”: “”,
    “exceptionDetail”: “”,
    “encoding”: “UTF-8”,
    “version”: “1.0”,
    “timestamp”: “1445950906202”,
    “description”: “”,
    “arguments”: {
        “props”: {
            “key”: “value”,
            ……
        }
    }
}






企业各职位英文缩写：
GM(General Manager)总经理
VP(Vice President)副总裁
FVP(First Vice President)第一副总裁
AVP(Assistant Vice President)副总裁助理
CEO(Chief Executive Officer)首席执行官，类似总经理、总裁，是企业的法人代表。
COO(Chief Operations Officer)首席运营官，类似常务总经理
CFO(Chief Financial Officer)首席财务官，类似财务总经理
CIO(Chief Information Officer)首席信息官，主管企业信息的收集和发布
CTO(Chief technology officer)首席技术官 类似总工程师
HRD(Human Resource Director)人力资源总监
OD(Operations Director)运营总监
MD(Marketing Director)市场总监
OM(Operations Manager)运作经理
PM(Production Manager)生产经理 (Product Manager)产品经理

其他：
CAO: Art 艺术总监
CBO: Business 商务总监
CCO: Content 内容总监
CDO: Development 开发总监
CGO: Gonverment 政府关系
CHO: Human resource 人事总监
CJO: Jet 把营运指标都加一个或多个零使公司市值像火箭般上升的人
CKO: Knowledge 知识总监
CLO: Labour 工会主席
CMO: Marketing 市场总监
CNO: Negotiation 首席谈判代表CPO: Public relation 公关总监
CQO: Quality control 质控总监
CRO: Research 研究总监
CSO: Sales 销售总监
CUO: User 客户总监
CVO: Valuation 评估总监
CWO: Women 妇联主席
CXO: 什么都可以管的不管部部长
CYO: Yes 什么都点头的老好人
CZO: 现在排最后，等待接班的太子

*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*﹀*
*******************************************
            ╭╮　　　　　　　╭╮　　
          　││　　　　　　　││　　
          ╭┴┴———————┴┴╮
          │　　　　　　　　　　　│　　　
          │　　　　　　　　　　　│　　　
          │　●　　　　　　　●　│
          │○　　╰┬┬┬╯　　○│
          │　　　　╰—╯　　　　│　
          ╰——┬Ｏ———Ｏ┬——╯
　 　           ╭╮　　　　╭╮　　　　
　            　╰┴————┴╯
  ╭══╮
╭╯ΘΘ ║
╰⊙═⊙╯。oо○Thanks & BestRegards  *^o^*

SwarmKit

http://java-design-patterns.com/
https://github.com/hoohack/DesignPattern

MQTT

http://iot.eclipse.org/projects


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Sign up
Sign in/Log in
Sign out

console/workbench/dashboard/main

shopping mall
sell

merchant
  products
  orders
  insights
  promote
    coupons
      Add New Coupon
  campaigns
    Create Campaign
  settings
    account
      The Basics
    general
      Brand Image
    shipping/preferences
      Shipping Rules
    policy
      Policies
    payment
    storefront
      Storefront
    notifications
      Notifications
  faq
    about/merchants/resources/faq



  cart
  settings
    profile
      Edit Profile
      Deactivate my account
    preferences
      Edit Preferences
    password
    notifications
      Notifications
    accounts
      Connected Accounts
    purchases
      Orders
    cards
      Payment Methods
    shipping
      Shipping Addresses
    credits
      credit
      referrals
      giftcards


    lists
    wishlist
    likes

report


connect?source=qq

topic
article

commodity/product/goods
goods,commodity,product,merchandise,wares这些名词都可表示“商品,货物”之意.
products是产品
goods是物品
commodity是日用品
merchandise是货物
详细点就是：
goods一般生活或商业用词,指销售或购入的商品.Goods 货物!
commodity作“商品”解时系经济学名词,也可指日用品.
product一般指工业产品,也可泛指各种各样的产品.
merchandise正式用词,指商业上销售或商家拥有货物的总称.
wares 指上市待卖的商品或货物.多用复数形式.
merchandise 商品,泛指商品,不特指某一商品

order

shopping cart


市场价 retail price
加盟价 franchise price
会员价 member price
商品单位 product unit
数量 amount
编号 product ID
单位 unit
类别 category
产品介绍 product description

对不起，您还没有登陆 sorry, you didn't log in yet.
添加购物 add to shopping cart
商品已经成功添加您的购物车 product added to your shopping cart
商品数量修改成功 product amount modified successfully
购物车被清空 your shopping is emptied (Your shopping cart is empty)
删除成功 deleted successfully

您从何处知道本网站  Where you heard our site from

递交 submit
重写 reset

你的数据添加成功 your information added successfully
你的数据添加失败 add information failed

申请会员成功 membership successfully registered
申请失败 membership apply failed










Payment method

Order summary

Choose a shipping address
Review order




Share
Share this with friends
Lists
Save this to your profile



活锁

------------------------------------------------------------------------------------------------------------------------
解决Tomcat catalina.out 不断成长导致档案过大的问题
Tomcat的网站上的说法http://wiki.apache.org/tomcat/FAQ/Logging#Q6：
System.out 和 System.err 都被打印到 catalina.out。
catalina.out 不会 rotate。
如果您使用了 logging 机制，就不会有任何东西被写到标准输出了，所以这应该不会是个问题。
可是实际上发现，虽然有设了log4j之类的 logging 机制，但写程序的人如果还是写成System.out.println()或是遇到exception时都来个e.printStackTrace()，这些输出最后还是通通送到catalina.out去了。日子久了，这个档案还是会日渐变大起来，如果没有加以管理最后就会长大成好几GB的庞然大物。（这时千万不要再用vi去开它了。）
网络上找了一下，针对在Linux环境下执行Tomcat的部份，发现有个不错的工具软件cronolog可以协助Web Server之类的做 log 檔的 rotate，详细的运作原理可能大家得自己去这个网站上查，我的认知大致如下：
Tomcat先把输出写到 console(标准输出) 然后透过 pipe (|) 转为 cronolog 的输入，由cronolog针对一个事先给定的文件名的命名规则，去过滤数据，定期关闭旧文件，然后再开启新档。如果我们将文件名的命名规则设为catalina.out.%Y-%m-%d，就可以做到每天开一个新的catalina.out.yyyy-mm-dd的档案了。
以下是简单的过程说明：
1.安装cronolog
2.修改catalina.sh
3.重新启动Tomcat

1 安装cronolog
wget http://cronolog.org/download/cronolog-1.6.2.tar.gz
tar zxvf cronolog-1.6.2.tar.gz
cd cronolog-1.6.2
./configure
make
make install

用which cronolog可以查到安装的路径，默认应该是/usr/local/sbin/cronolog，这个路径待会在修改catalina.sh时会用到。
2 修改catalina.sh
以Tomcat 6.0.24的版本为例
2.1 第一步
将
if [ -z "$CATALINA_OUT" ] ; then
CATALINA_OUT="$CATALINA_BASE"/logs/catalina.out
fi
修改为
if [ -z "$CATALINA_OUT" ] ; then
CATALINA_OUT="$CATALINA_BASE"/logs/catalina.out.%Y-%m-%d
fi
2.2 第二步
将
touch "$CATALINA_OUT"
改为
#touch "$CATALINA_OUT"
2.3 第三步
将
org.apache.catalina.startup.Bootstrap "$@" start /
>> "$CATALINA_OUT" 2>&1 &
修改为
org.apache.catalina.startup.Bootstrap "$@" start 2>&1 /
| /usr/local/sbin/cronolog "$CATALINA_OUT" >> /dev/null &
2.4 重新启动Tomcat
service tomcat restart
可以在Tomcat的logs目录底下找到以系统日期为结尾的catalina.out.yyyy-mm-dd的档案，这样子就成功了。
后续就是持续观察看看是不是每天都有产生一个新的catalina.out.yyyy-mm-dd档案。然后再安排定期删除这些较旧的log檔即可。


Linux下的tomcat产生的日志文件不象windows下的按时间时间和大小来处理，
尽管也生成了日志文件catalina.2009-0x-0x.log类型的文件，但是其中的catalina.out文件依然增大；它为啥在增大，为啥在增大，原因我就不探究了。

Tomcat的官方文档，由于是外文，偶还没有看明白di；
http://tomcat.apache.org/tomcat-6.0-doc/logging.html
据说是修改某些配置可以实现，希望高人指点，给个官方的解决方案；
老是增大也不是办法，还是想其他办法搞定它为好：
方法1—分割流
使用cronolog工具切分Tomcat的catalina.out日志文件
cronolog一个对日志切分的小工具，其主页在http://cronolog.org/，我们也可以用它来切分Apache的日志。
具体的方法，您可以去google之，这个方法占网络搜索结果的主流；
方法2—脚本流
事情终究不过是个大文件处理的问题，强大的bash来搞定；
使用cron每天来备份当前的catalina.out，然后清空他的内容；
参考脚本如下：
#!/bin/sh
y=`date "+%Y"`
m=`date "+%m"`
d=`date "+%d"`
cd /PATH /tomcat/logs
cp catalina.out catalina.out.$y$m$d
echo > catalina.out
exit
注意linux系统的cron服务是否启动，是否正常工作，还有脚本的存放路径（原因暂保密）

方法3—猥琐流
打开bin目录下的catalina.sh文件，终究不过是个bash文件，
查找一下，catalina.out总共出现三次；
部分截图：
shift
touch "$CATALINA_BASE"/logs/catalina.out
if [ "$1" = "-security" ] ; then
    echo "Using Security Manager"
    shift
    "$_RUNJAVA" $JAVA_OPTS "$LOGGING_CONFIG" $CATALINA_OPTS \
      -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \
      -Djava.security.manager \
      -Djava.security.policy=="$CATALINA_BASE"/conf/catalina.policy \
      -Dcatalina.base="$CATALINA_BASE" \
      -Dcatalina.home="$CATALINA_HOME" \
      -Djava.io.tmpdir="$CATALINA_TMPDIR" \
      org.apache.catalina.startup.Bootstrap "$@" start \
      >> "$CATALINA_BASE"/logs/catalina.out 2>&1 &
      if [ ! -z "$CATALINA_PID" ]; then
        echo $! > $CATALINA_PID
      fi
else
    "$_RUNJAVA" $JAVA_OPTS "$LOGGING_CONFIG" $CATALINA_OPTS \
      -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \
      -Dcatalina.base="$CATALINA_BASE" \
      -Dcatalina.home="$CATALINA_HOME" \
      -Djava.io.tmpdir="$CATALINA_TMPDIR" \
      org.apache.catalina.startup.Bootstrap "$@" start \
      >> "$CATALINA_BASE"/logs/catalina.out 2>&1 &
个人觉得也就是这里是写catalina.out文件的；让他写到一个其他的空设备如何？
修改前注意原文件的catalina.sh的备份哟~！！
修改以上代码中的
>> "$CATALINA_BASE"/logs/catalina.out 2>&1 &
为
>> /dev/null 2>&1 &
保存，然后启动tomcat，目前这个 catalina.out一直是空的了。
这个方法是偶自己想到的，个人认为比较勇敢，目前还没有在生产环境测试过。虚拟机测试是通过的。

方法4—人流
这个方法其实就是linux系统管理员手工去删除，人工操作，简称“人流”；
删除之前最好停止tomcat的服务；
------------------------------------------------------------------------------------------------------------------------


Paxos和Raft
Consensus

Nginx（或HAProxy） +keepalived

Keepalived
ZooKeeper

http://www.haproxy.org/

http://thesecretlivesofdata.com/raft/
CAP原理和BASE思想
http://www.jdon.com/37625
分布式系统Paxos算法
http://www.jdon.com/artichect/paxos.html

2PC到3PC到Paxos到Raft到ISR
https://segmentfault.com/a/1190000004474543

射线光学理论



<servlet>
    <servlet-name>chapter2</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-servlet-config.xml</param-value>
    </init-param>
</servlet>


RabbitMq、ActiveMq、ZeroMq、kafka
http://flume.apache.org/
https://github.com/facebookarchive/scribe
http://chukwa.apache.org/
http://flink.apache.org/
http://kafka.apache.org/

jackson
com.fasterxml.jackson
http://community.jaspersoft.com/project/jasperreports-library
https://github.com/flexpaper/pdf2json
https://flowpaper.com/download/
https://github.com/flexpaper/flexpaper

Libxml
http://xmlsoft.org/

lua
http://www.lua.org/

libpng
http://www.libpng.org/

json
http://www.json.org/json-zh.html


XML、JSON、ProtocolBuffer、Lua
http://lua-users.org/wiki/JsonModules

http://thrift.apache.org



Zookeeper在集群负载均衡中的应用
Zookeeper本身是不提供负载均衡的策略,需要自己来实现，所以这里确切的说，是在负载均衡中应用到了Zookeeper做集群的协调。
对于HTTP请求的负载均衡，成熟的解决方案是Nginx（或Haproxy） +keepalived。其中Niginx负责代理HTTP请求，通过某种均衡策略访问集群中的服务器，keepalived负责检测集群中的服务器运行情况（有故障的机器移除，机器恢复工作后重新加入）
而对于TCP层的负载均衡，比如用Apache Mina做的网络通信应用，上面那种方案明显不适合，因为网络通信客户端和服务端要保持长连接
所以要针对这种长连接做负载均衡，一般都是基于连接数这种均衡策略，也就是在第一次连接时，分配服务器IP时，取当前连接数最少的那台
集群中有几台服务器处于运行状态，每一台服务器当前连接的客户数量，最大连接数量，等等这些信息需要记录起来，然后每次做负载均衡时根据这些信息来做分配，一般首先想到的是把这些信息存放在数据库里
简单的做法就是服务器启动时，把数据库里相应的状态改为运行，有客户连接或断开时，把连接数做加数或减数运算。
当服务器关闭时，问题就来了：
1、服务器关闭，可能数据源也已经被关闭，没法操作数据库，该机器在数据库里一直处于运行状态
2、服务器宕机，这种问题就很致命，这是连关闭的程序都没有执行，更不用说能操作数据库了
解决的方式就是用Zookeeper保存服务器的连接信息
1、当服务器启动时，往Zookeeper的节点里写入数据（节点类型是临时节点）
2、当服务器关闭时，从Zookeeper移除相应的节点数据
3、当服务器宕机，Zookeeper因为没有检测到心跳，自动把该节点移除，并通知其他服务器，其他服务器得知该机器已宕机，在分配连接时，不会分配到这台机器上，这点也是标题说的在负载均衡中用到Zookeeper的原因。
对比了一下保存在数据库那种方式，Zookeeper其实就是一个具有通知功能的数据库，也就是它底下节点数据有变化时，会通知它的所有客户端（这里的客户端指的连接到Zookeeper的服务器）。


HA和负载均衡的区别
1、HA（High Available）：主要解决可靠性问题，设备、部件的互备等，通过技术也可以实现部分的流量负载分担功能。
　常见的有服务器的HA，俗称双机热备；
　网络的HSRP/vrrp/glp，以及各厂商的私有技术，像cisco防火墙的failover，juniper防火墙的nsrp等等。
2、负载均衡：可分为网络层面和应用层面
　网络层面一般可能使用端口聚合、多路径等技术，主要在网络层面实现流量负载均衡。
　应用层面的负载均衡，主要厂商有F5、radware、cisco等等，通过专用的负载均衡设备实现基于不同应用类型的负载均衡。
两个就不是一回事，不可相比，一个用于设备冗灾，一个用于流量分分担

HA
http://blog.csdn.net/e421083458/article/details/30092795
http://www.cnblogs.com/holbrook/archive/2012/10/25/2738475.html
https://yq.aliyun.com/articles/24155
http://blog.sina.com.cn/s/blog_4e424e2101007rie.html

OpenVPN
OpenGl
WebGl


http://www.firewalld.org/documentation/howto/open-a-port-or-service.html


x        删除当前光标下的字符
dw       删除光标之后的单词剩余部分。
d$       删除光标之后的该行剩余部分。
dd       删除当前行。

c        功能和d相同，区别在于完成删除操作后进入INSERT MODE
cc       也是删除当前行，然后进入INSERT MODE
删除每行第一个字符    :%s/^.//g


同步时间
ntpdate 172.16.0.1


证明（递归）、算法（递归）、语言（λ演算[10]）、操作系统（指针）、编译器（λ演算）


服务发现 zookeeper ,consul ,etcd
zipkin为分布式链路调用监控系统，聚合各业务系统调用延迟数据，达到链路调用监控跟踪。

netflix
zuul用来提供动态路由、监控、授权、安全、调度等等的边缘服务(edge service)。
feign是一个类似retrofit进行http调用框架，Feign makes writing Java http clients easier 使得编写http client代码更加简单。
eureka 用以服务发现、服务注册，比较流行的有consul。
ribbon用以实现负载均衡；实现软负载均衡，核心有三点：
1.服务发现，发现依赖服务的列表
2.服务选择规则，在多个服务中如何选择一个有效服务
3.服务监听，检测失效的服务，高效剔除失效服务
turbine是聚合服务器发送事件流数据的一个工具，hystrix的监控中，只能监控单个节点，实际生产中都为集群，因此可以通过turbine来监控集群下hystrix的metrics情况，通过eureka来发现hystrix服务。
hystrix通过服务隔离、熔断(也可以称为断路)、降级等手段控制依赖服务的延迟与失败。

http://www.ruanyifeng.com/
http://blog.bomoo.com/pin/


两种I/O多路复用模式：Reactor和Proactor

RxJava: Reactive Extensions for the JVM
Querydsl
https://ebean-orm.github.io/
http://ignite.apache.org/
https://www.consul.io


 MATLAB和Mathematica、Maple并称为三大数学软件

 布隆过滤器(Bloom Filter)

SNMP

BPEL：全称为Business Process Execution Language,即业务流程执行语言，是一种使用XML编写的编程语言。用于自动化业务流程，也曾经被称作WSBPEL和 BPEL4WS。广泛使用于Web服务相关的项目开发中，优点为具有可移植性和有效保护了投资。


Spring Security

under active development.
has much more community support.
Spring security has extensions providing support for both Oauth and kerberos and SAML.

Shiro

Does not support saml or Oauth.
Makes no mention of supporting before and after security policies.
Active development seems limited, the website still contains erroneous information.


DevOps


领域通用语言（UBIQUITOUS LANGUAGE）
UnitOfWork
Factory
Repository
Event Sourcing
Aggregate，Aggregate Root
Domain Service
Value Object
Entity

User Interface
Application
Domain
Infrastructure

事务
池化
虚拟
存储
协议
算法


一,事务的4个基本特征
Atomic（原子性）：
事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。
Consistency（一致性）：
只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。
Isolation（隔离性）：
事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。
Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。
二,为什么需要对事务并发控制
如果不对事务进行并发控制，我们看看数据库并发操作是会有那些异常情形
Lost update：
两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。
Dirty Reads：
一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚。
Non-repeatable Reads： 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。
Second lost updates problem： 无法重复读取的特例。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。
Phantom Reads：
事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。
三, 数据库的隔离级别
为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（Oracle和SQLSERER对标准隔离级别有不同的实现 ）
Read Uncommitted：
直译就是"读未提交",意思就是即使一个更新语句没有提交,但是别的事务可以读到这个改变.这是很不安全的.
Read Committed：
直译就是"读提交",意思就是语句提交以后即执行了COMMIT以后别的事务就能读到这个改变.
Repeatable Read：
直译就是"可以重复读",这是说在同一个事务里面先后执行同一个查询语句的时候,得到的结果是一样的.
Serializable:
直译就是"序列化",意思是说这个事务执行的时候不允许别的事务并发执行.
四，隔离级别对并发的控制
下表是各隔离级别对各种异常的控制能力。
 	LU	DR	NRR	SLU	PR
RU	Y	Y	Y	Y	Y
RC	N	N	Y	Y	Y
RR	N	N	N	N	Y
S	N	N	N	N	N
(注：LU：丢失更新；DR：脏读；NRR：非重复读；SLU：二类丢失更新；PR：幻像读)



Hibernate占位符问题[use named parameters or JPA-style positional parameters instead.]

hibernate 4.1之后对于HQL中查询参数的占位符做了改进，如果仍然用老式的占位符会有类似如下的告警信息：

[main] WARN  [org.hibernate.hql.internal.ast.HqlSqlWalker] – [DEPRECATION] Encountered positional parameter near line 1, column 95.  Positional parameter are considered deprecated; use named parameters or JPA-style positional parameters instead.
从告警提示信息中可以看出，它建议用命名参数或者JPA占位符两中种方法来代替老的占位符查询方法。

比如老的占位符查询代码片段：
String hql = "select t from Blog t where t.site=?";
Query query = getSession().createQuery(hql);
query.setParameter(0, "simple.com");
方法一：改成命名参数的方式：

// 命名参数的方式
String hql2 = "select t from Blog t where t.site=:site";
Query query2 = getSession().createQuery(hql2);
query2.setParameter("site", "simple.com");
方法二：改成JPA占位符的方式：

// JPA占位符方式
String hql3 = "select t from Blog t where t.site=?0";
Query query3 = getSession().createQuery(hql3);
query2.setParameter(0, "simple.com");
其中"?"后面的"0"代表索引位置，在HQL语句中可重复出现，并不一定要从0开始，可以是任何数字，只是参数要与其对应上。


EventSource

sveltejs
vuejs
cyclejs

Kubernetes
TensorFlow

Lamda

Trie树
B-tree
B+ Tree
B* Tree
R-tree
Red–black tree
2–3 tree
2–3–4 tree
伸展树
Treap树
平衡二叉树
二叉查找树

------------------------------------------------------------------------------------------------------------------------
http://blog.jobbole.com/30940/

LFU Least Frequently Used 最近最少使用算法，一定时间段内使用次数（频率）最少的那个被移除；
LRU Least Recently Used 最久未使用算法，使用时间距离现在最久的那个被移除；
LRU2 Least Recently Used 2 最少使用 twice
LIRS Low Inter-reference Recency Set
ARC Adaptive Replacement Cache
MRU Most Recently Used
FIFO First in First out 先进先出算法，即先放入缓存的先被移除；
Second Chance
CLock
Simple time-based
Extended time-based expiration
Sliding time-based expiration
LeftOver 机制
Random Cache


Two Queues（2Q）

1.最佳置换算法(Optimal)：它是由Belady于1966年提出的一种理论上的算法。其所选择的被淘汰页面，将是以后永不使用的或许是在最长(未来)时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。但由于人目前还无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的，便可以利用此算法来评价其它算法。
2.先进先出(FIFO)页面置换算法：这是最早出现的置换算法。该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。
3.LRU置换算法：这是本次设计的重点。
4.CLOCK置换算法：a,简单CLOCK置换算法；b,改进型CLOCK算法。LRU算法是较好的一种算法，而由于LRU在硬件上要求较多，在实际应用中多采用LRU的近似算法。CLOCK算法就是用得较多的一种LRU近似算法。
5.最少使用(LFU:Least Frequently Used)置换算法：在采用该算法时，应为在内存中的每个页面设置一个移位寄存器骼来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面为淘汰页。
6.页面缓冲算法(PBA：Page Buffering Algorithm)

TTL（Time To Live ）
存活期，即从缓存中创建时间点开始直到它到期的一个时间段（不管在这个时间段内有没有访问都将过期）

TTI（Time To Idle）
空闲期，即一个数据多久没被访问将从缓存中移除的时间。

缓存命中率

即从缓存中读取数据的次数 与 总读取次数的比率，命中率越高越好：
命中率 = 从缓存中读取次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数])
Miss率 = 没有从缓存中读取的次数 / (总读取次数[从缓存中读取次数 + 从慢速设备上读取的次数])
------------------------------------------------------------------------------------------------------------------------

GB/T 7714-2005
制定机构：国家质量监督检验检疫总局和中国标准化管委会
适用范围：国内发表刊物（自然科学国际上采用AMA格式，新闻报刊采用Chicago格式）
引用格式：作者名+作品名+标识码+刊物名+年份+刊号+页码
插注格式：中括号扩上数字标号，加上标  e.g. XXX[3]
Borst S, Gupta V, Walid A. Distributed Caching Algorithms for Content Distribution Networks[C]// Conference on Information Communications. IEEE Press, 2010:1478-1486.

APA
制定机构：美国心理学会 American Psychological Association
适用范围：主要是心理学、教育学、社会科学
引用格式：作者名+年份+作品名+刊物名斜体+刊号斜体+页码
插注格式：“作者和日期”的引用方式和“括号内引用法”  e.g. (ABC, 1999)
Borst, S., Gupta, V., & Walid, A. (2010). Distributed Caching Algorithms for Content Distribution Networks. Conference on Information Communications (Vol.54, pp.1478-1486). IEEE Press.

MLA
制定机构：美国现代语言协会 Modern Language Association
适用范围：主要人文学科，如文学、比较文学、文学批评和文化研究等
引用格式：作者名+引号作品名+刊物名斜体+刊号+年份+页码
插注格式：作者加页码的引用，不在引用时标注日期  e.g. (ABC 53)
Borst, S, V. Gupta, and A. Walid. "Distributed Caching Algorithms for Content Distribution Networks." Conference on Information Communications IEEE Press, 2010:1478-1486.


title="Cost-aware WWW proxy caching algorithms",
author="Cao, Pei and Irani, Sandy",
booktitle={Usenix Symposium on Internet Technologies and Systems on Usenix Symposium on Internet Technologies and Systems},
pages="18-18",
year="1997",


物理内存、页面文件、交换区和虚拟内存

------------------------------------------------------------------------------------------------------------------------
/etc/sysconfig/i18n 这里存放的是系统的区域语言设置， i18n是  国际化internationalization的缩写 i和n之间正好18个字母
第一行  表明你当前系统的语言环境变量设置 ，这里是 zh_CN.GB18030
第二行  表明系统预置了那些语言支持 ，不在项目中的语言不能正常显示
第三行  定义控制台终端字体，你文本登录的时候显示的字体就是这个 latarcyrheb-sun16

设置中文编码
$vi /etc/sysconfig/i18n
内容如下：
LANG="zh_CN.UTF-8"
SUPPORTED="zh_CN:zh:en_US.UTF-8:en_US:en:zh_CN.GB18030"
SYSFONT="latarcyrheb-sun16"

让配置生效
$source /etc/sysconfig/i18n

------------------------------------------------------------------------------------------------------------------------

Moore状态机和Mealy状态机


XML、JSON、ProtocolBuffer、Lua

anonymous,guest


ntpdate cn.pool.ntp.org
更新完后要用 clock -w 或 hwclock -w 实时间写入到BIOS中，这样下次启动时，时间就会自动更新了。


------------------------------------------------------------------------------------------------------------------------
Linux下清理内存和Cache方法 /proc/sys/vm/drop_caches

频繁的文件访问会导致系统的Cache使用量大增

$ free -m
total used free shared buffers cached
Mem: 3955 3926 28 0 55 3459
-/+ buffers/cache: 411 3544
Swap: 5726 0 5726

free内存减少到几十兆，系统运行缓慢

运行sync将dirty的内容写回硬盘
$sync

读写文件时，Linux内核为了提高读写效率与速度，会将文件在内存中进行缓存，这就是Cache Memory(缓存内存)。即使程序运行结束后，Cache Memory也不会自
动释放。这就会导致程序频繁读写文件后，可用物理内存会很少，在你需要使用内存的时候会自动释放，如果你希望手动去释放Cache Memory(缓存内存)，在清理缓
存（drop_caches）的官方文档：http://www.kernel.org/doc/Documentation/sysctl/vm.txt，已有说明。

通过修改proc系统的drop_caches清理free的cache
$echo 3 > /proc/sys/vm/drop_caches

drop_caches的详细文档如下：
Writing to this will cause the kernel to drop clean caches, dentries and inodes from memory, causing that memory to become free.
To free pagecache:
* echo 1 > /proc/sys/vm/drop_caches
To free dentries and inodes:
* echo 2 > /proc/sys/vm/drop_caches
To free pagecache, dentries and inodes:
* echo 3 > /proc/sys/vm/drop_caches
As this is a non-destructive operation, and dirty objects are notfreeable, the user should run "sync" first in order to make sure allcached objects are freed.
This tunable was added in 2.6.16.

修改/etc/sysctl.conf 添加如下选项后就不会内存持续增加
vm.dirty_ratio = 1
vm.dirty_background_ratio=1
vm.dirty_writeback_centisecs=2
vm.dirty_expire_centisecs=3
vm.drop_caches=3
vm.swappiness=100
vm.vfs_cache_pressure=163
vm.overcommit_memory=2
vm.lowmem_reserve_ratio=32 32 8
kern.maxvnodes=3

上面的设置比较粗暴，使cache的作用基本无法发挥。需要根据机器的状况进行适当的调节寻找最佳的折衷。
------------------------------------------------------------------------------------------------------------------------

framebuffer
Cairo
https://www.cairographics.org/
Skia
https://skia.org/
FreeType
xlib
XCB
x.org
AGG
http://www.antigrain.com/
pixman
http://www.pixman.org/

------------------------------------------------------------------------------------------------------------------------
Firebase Meteor

什么是 Meteor？
Meteor 是一种新的 JavaScript 框架，用于自动化和简化实时运行的 Web 应用程序的开发。它使用一个名为分布式数据协议 (Distributed Data Protocol, DDP) 的协议来处理实时通信，使用 WebSockets 的新浏览器以及使用 Asynchronous JavaScript + XML (Ajax) 长轮询的旧浏览器来支持这种协议。在这两种情况下，浏览器到服务器的通信是透明的。
DDP 协议旨在处理 JavaScript Serialized Object Notation (JSON) 文档集合，使 JSON 文档容易创建、更新、删除、查询和访问。因为 DDP 是一种开源协议，所以您可将它连接到任何客户端或数据存储。它为 MongoDB 提供了开箱即使用支持。
事实上，Meteor 提供了两个 MongoDB 数据库：一个客户端缓存数据库和服务器上的一个 MongoDB 数据库。当一个用户更改一些数据时（例如通过单击 Save），在浏览器中运行的 JavaScript 代码会更新本地 MongoDB 中的相应的数据库项，然后向服务器发出一个 DDP 请求。该代码立即像操作已获得成功那样继续运行，因为它不需要等待服务器回复。与此同时，服务器在后台更新。如果服务器操作失败或返回一个意外结果，那么客户端 JavaScript 代码会依据从服务器新返回的数据立即进行调整。这种调整称为延迟补偿，向用户提供了更高的认知速度。
显然，甚至连 Meteor 的模板系统也是为简化实时通信而设计的。在大多数 Web 框架中，您可以轻松地混合使用超文本标记语言 (HTML) 和代码，或者与 HTML 等效的标记，比如 HTML 抽象标记语言 (Haml)。这使您能够轻松地将来自数据库的动态值插入发送给用户的页面中。在这之后，您应该负责准备提供一个系统来观察对数据的更改，然后更新您的标记。但是，Meteor 中的模板系统用于记录访问了模板中的哪些数据，并自动回调，以便在底层数据更改时调用此 HTML，使实时模板变得更加简单快捷。

------------------------------------------------------------------------------------------------------------------------
什么是中断
Linux 内核需要对连接到计算机上的所有硬件设备进行管理，毫无疑问这是它的份内事。如果要管理这些设备，首先得和它们互相通信才行，一般有两种方案可实现这种功能：
轮询（polling） 让内核定期对设备的状态进行查询，然后做出相应的处理；
中断（interrupt） 让硬件在需要的时候向内核发出信号（变内核主动为硬件主动）。
第一种方案会让内核做不少的无用功，因为轮询总会周期性的重复执行，大量地耗用 CPU 时间，因此效率及其低下，所以一般都是采用第二种方案 。

------------------------------------------------------------------------------------------------------------------------
http://ramdajs.com/


master slave backup

gzip是一种数据格式，默认且目前仅使用deflate算法压缩data部分；
deflate是一种压缩算法,是huffman编码的一种加强。


gcc生成.a静态库和.so动态库文件

o 生成静态库的方法
$ gcc -c gdfontwu.c
$ gcc -c gdfontliu.c
$ gcc -c gdfontbin.c
$ ar rc libgdfont.a gdfontwu.o gdfontliu.o gdfontbin.o
(ranlib libgdfont.a 可生成索引)
用 nm libgdfont.a 来看里面的目标文件和导出函数（带 T 标记）。

o 生成动态库的方法
$ gcc -c gdfontwu.c
$ gcc -c gdfontliu.c
$ gcc -c gdfontbin.c
$ gcc -o libgdfont.so -shared -fPIC gdfontwu.o gdfontliu.o gdfontbin.o
-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码
是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程
需要，而不能达到真正代码段共享的目的。可用 nm libgdfont.so 来看
里面导出的函数（带 T 标记）。
用动态库的好处是：更新了动态库之后链结它的程序不用重新编译。

o 用法
在 websrv.c 中：
/* websrv.c */
#include "gdfontwu.h"
#include "gdfontliu.h"
#include "gdfontbin.h"
int getpng()
{
    ...
    gdImageChar(..., gdFontWu, ...);
    gdImageChar(..., gdFontLiu, ...);
    gdImageChar(..., gdFontBin, ...);
    ...
    return 0;
}
> 静态库:
$ gcc -c websrv.c
$ gcc -o websrv websrv.o libgdfont.a

> 动态库：
$ gcc -o websrv websrv.o -L. -lgdfont
$ LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH ./websrv
LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH ldd main
可以看到 websrv 程序所链结的动态库。把 libgdfont.so 放到
/etc/ld.so.conf 中列出的目录下就可以不用先指定环境变
，注意先 ldconfig 刷新系统动态库的缓存
还有一种 ld -rpath dir 这样的方法可避免设定环境变量

RxJava
http://reactivex.io/languages.html

https://www.x.org/wiki/
X11/Xlib
framebuffer

https://www.viksoe.dk/code/

https://tronche.com/gui/x/xlib-tutorial/2nd-program-anatomy.html
https://tronche.com/gui/x/xlib/
https://www.x.org/docs/X11/xlib.pdf
libxcb
https://www.x.org/releases/X11R7.7/doc/libxcb/tutorial/index.html


http://www.jianshu.com/u/1f0067e24ff8

三面娜迦

Cron Expressions
1）Cron表达式的格式：秒 分 时 日 月 周 年(可选)。

Cron Expressions Allowed Fields and Values
字段名(Name)          Required       允许的值(Allowed Values)        允许的特殊字符(Allowed Special Characters)
秒(Seconds)          Y              0-59                           , - * /
分(Minutes)          Y              0-59                           , - * /
时(Hours)            Y              0-23                           , - * /
日(Day-of-Month)     Y              1-31                           , - * ? / L W C
月(Month)            Y              0-11 or JAN-DEC                , - * /
周(Day-of-Week)      Y              1-7 or SUN-SAT                 , - * ? / L C #
年(Year 可选)         N              empty, 1970-2099               , - * /

“*”字符：代表整个时间段.
“?”字符：表示不确定的值
“,”字符：指定数个值
“-”字符：指定一个值的范围
“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m
“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X
“W”字符：指定离给定日期最近的工作日(周一到周五)
“#”字符：表示该月第几个周X。6#3表示该月第3个周五

每一个字段都有一套可以指定有效值，如
Seconds(秒)：可以用数字0－59 表示，
Minutes(分)：可以用数字0－59 表示，
Hours(时)：可以用数字0-23表示,
Day-of-Month(天)：可以用数字1-31 中的任一一个值，但要注意一些特别的月份
Month(月)：可以用0-11 或用字符串  “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示
Day-of-Week(每周)：可以用数字1-7表示（1 ＝ 星期日）或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”表示

“*”: 代表整个时间段.
“/”：为特别单位，表示为“每”如“0/15”表示每隔15分钟执行一次,“0”表示为从“0”分开始, “3/20”表示表示每隔20分钟执行一次，“3”表示从第3分钟开始执行
“?”：表示每月的某一天，或第周的某一天
“L”：用于每月，或每周，表示为每月的最后一天，或每个月的最后星期几如“6L”表示“每月的最后一个星期五”
“W”：表示为最近工作日，如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”
“#”：是用来指定“的”每月第n个工作日,例 在每周（day-of-week）这个字段中内容为"6#3" or "FRI#3" 则表示“每月第三个星期五”

例:"0 0 12 ? * WED" 在每星期三下午12:00 执行,("WED")可以替换成 "MON-FRI", "MON, WED, FRI"甚至"MON-WED,SAT".

2）Cron表达式范例：
每隔5秒执行一次：*/5 * * * * ?
每隔1分钟执行一次：0 */1 * * * ?
每天23点执行一次：0 0 23 * * ?
每天凌晨1点执行一次：0 0 1 * * ?
每月1号凌晨1点执行一次：0 0 1 1 * ?
每月最后一天23点执行一次：0 0 23 L * ?
每周星期天凌晨1点实行一次：0 0 1 ? * L
在26分、29分、33分执行一次：0 26,29,33 * * * ?
每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?

Here are some more examples:

Expression	                Means
0 0 12 * * ?	        	Fire at 12:00 PM (noon) every day
0 15 10 ? * *	        	Fire at 10:15 AM every day
0 15 10 * * ?	        	Fire at 10:15 AM every day
0 15 10 * * ? *	        	Fire at 10:15 AM every day
0 15 10 * * ? 2005	    	Fire at 10:15 AM every day during the year 2005
0 * 14 * * ?	        	Fire every minute starting at 2:00 PM and ending at 2:59 PM, every day
0 0/5 14 * * ?	        	Fire every 5 minutes starting at 2:00 PM and ending at 2:55 PM, every day
0 0/5 14,18 * * ?	    	Fire every 5 minutes starting at 2:00 PM and ending at 2:55 PM, AND fire every 5 minutes starting at 6:00 PM and ending at 6:55 PM, every day
0 0-5 14 * * ?	        	Fire every minute starting at 2:00 PM and ending at 2:05 PM, every day
0 10,44 14 ? 3 WED	    	Fire at 2:10 PM and at 2:44 PM every Wednesday in the month of March
0 15 10 ? * MON-FRI	    	Fire at 10:15 AM every Monday, Tuesday, Wednesday, Thursday and Friday
0 15 10 15 * ?	        	Fire at 10:15 AM on the 15th day of every month
0 15 10 L * ?	        	Fire at 10:15 AM on the last day of every month
0 15 10 ? * 6L	        	Fire at 10:15 AM on the last Friday of every month
0 15 10 ? * 6L	        	Fire at 10:15 AM on the last Friday of every month
0 15 10 ? * 6L 2002-2005	Fire at 10:15 AM on every last friday of every month during the years 2002, 2003, 2004, and 2005
0 15 10 ? * 6#3	        	Fire at 10:15 AM on the third Friday of every month
0 0 12 1/5 * ?	        	Fire at 12 PM (noon) every 5 days every month, starting on the first day of the month
0 11 11 11 11 ?	        	Fire every November 11 at 11:11 AM


Wireless

一致性哈希算法
https://github.com/icloudkit/coding-interview-university/blob/master/translations/README-cn.md

area

nationality
province
city

monitor
overview

developer


yiwan.net

for /l %i in (1,1,99) do @type nul>%i.pdf

-------------------------------------------------------------------------------------------
$('body').append("<input type=\"text\" id=\"pdf-view\" />");

var listItem = "";
var i = 1;

self.setInterval(function(){
    listItem = $('#outer_page_' + i).html();
    // console.log(listItem);
	$('#pdf-view').val($('#pdf-view').val() + listItem);
    $('#nextPageButton').click();
    i++;
}, 1000);



专业、简单、无限可能

驰而不息

生命不息 数据不止
计算和数据生生不息
让数据栩栩如生

坚持不懈，永不停息

智慧未来
生态系统

传递 通信

发现、分享、创造\缔造生活之美

每个人都有自己的生活
每个人都会有梦想，有大梦想，有小梦想

最优解

如赛场
未分级

网络
点 线 面

连接、映射、化简、过虑、分发、转换、编码、解码、路由、编排/重排、适配、变换、聚合、包装、清除、扩充、分派、分解

心满意足

集成供应链
信息流
物流
资金流


您每个夜晚都会休息
但您的梦想却依然清醒
因为抱负从不歇息
激情从不歇息
目标从不歇息
希望从不歇息
机会从不歇息
这个世界也从不歇息
所以 我们不分国界
不分昼夜
为您全力实现每个梦想
所以 花旗从不歇息

Every night you sleep
But your dreams are wide awake because
Ambitions never sleep
Aspirations never sleep
Goals never sleep
Hopes never sleep
Opportunities never sleep
The world never sleeps
That's why we work around the world
That's why we work around the clock
To turn dreams into realities
That's why Citi never sleeps


人的等级，这种等级在人获得物质上的自由之前是以财富来划分的，而人在获得了物质上的自由后、获得精神上的自由之前是以智力来划分的，而人获得精神上的自由之后是以所抵达的审美的境界来划分的，最后以是否完成了“自我现实”来划分。每一个人追求的最终极的目标都是“自我实现”，可以是信仰的方式，也可以是非信仰的方式，总之人最终获得了诗意的栖居，天人合一。


Sketch

Java内存对象的逃逸分析



七大基础学科依次为数学、逻辑学、天文学和天体物理学、地球科学和空间科学、物理学、化学、生命科学

数学
数学是研究数量、结构、变化以及空间模型等概念的一门学科。透过抽象化和逻辑推理的使用，由计数、计算、量度和对物体形状及运动的观察中产生。数学家们拓展这些概念，为了公式化新的猜想以及从合适选定的公理及定义中建立起严谨推导出的真理。
数学又包括：几何学、初等数学、高等数学、模糊数学、代数等。

逻辑学
旧称“论理学”、“理则学”、“名学”、“辩学”。关于思维形式及其规律的学科，由亚里士多德创立。由德国古典哲学家们创立的逻辑学使逻辑学进入了一个新的领域。黑格尔把思维形式的发展与人的认识的各个阶段紧密结合起来进行研究，这些思维形式彼此联系、相互转化，又具有新的意义。

天文学
天文学(Astronomy)是研究宇宙空间天体、宇宙的结构和发展的学科。内容包括天体的构造、性质和运行规律等。主要通过观测天体发射到地球的辐射，发现并测量它们的位置、探索它们的运动规律、研究它们的物理性质、化学组成、内部结构、能量来源及其演化规律。天文学是一门古老的科学，自有人类文明史以来，天文学就有重要的地位。

天体物理学
天体物理学是应用物理学的技术、方法和理论，研究天体的形态、结构、化学组成、物理状态和演化规律的天文学分支学科。

地球科学
地球科学 是以地球系统(包括大气圈、水圈、岩石圈、生物圈和日地空间)的过程与变化及其相互作用为研究对象的基础学科。主要包括地理学(含土壤学与遥感)、地质学、地球物理学、地球化学、大气科学、海洋科学和空间物理学j以及新的交叉学科（地球系统科学、地球信息科学）等分支学科。地球科学是一个大题目，纵横几万里，上下数亿年，几乎辐射到自然科学的其他各个领域。对地球的认识同世界各民族的起源、历史、文化乃至这个世界文明的进展，都是紧密联系在一起的。

空间科学
空间科学（space science）是指利用航天器研究发生在日地空间、行星际空间及至整个宇宙空间的物理、天文、化学及生命等自然现象及其规律的科学。空间科学以航天技术为基础，包括空间飞行、空间探测和空间开发等几个方面。它不仅能揭示宇宙奥秘，而且也给人类带来巨大的利益。

化学
化学（Chemistry）是研究物质的组成、结构、性质、以及变化规律的科学。世界是由物质组成的，化学则是人类用以认识和改造物质世界的主要方法和手段之一，它是一门历史悠久而又富有活力的学科，它的成就是社会文明的重要标志。

生命科学
生命科学是研究生命现象、生命活动的本质、特征和发生、发展规律，以及各种生物之间和生物与环境之间相互关系的科学。用于有效地控制生命活动，能动地改造生物界，造福人类生命科学与人类生存、人民健康、经济建设和社会发展有着密切关系，是当今在全球范围内最受关注的基础自然科学。



如何判断VPS是基于哪种虚拟技术？
Xen、OpenVZ、Xen HVM、KVM还是VMware

对于VPS新手来说，怕被无良的奸商给忽悠，下的Xen的却给的OpenVZ的，如何来判断自己买的VPS是那种虚拟技术的，下面VPS侦探整理一些常见的方法。
1、通过系统上的相关目录或文件判断
执行：ls /proc/ ，一般Xen的VPS，/proc目录下面会有xen的目录，openvz的会有vz目录。
2、执行：free -m 看内存，openvz的没有swap，当然也有xen的没有swap，但是xen的是可以加的，openvz不行。KVM是全虚拟化也是可以自己添加swap的。
3、执行：uname -a  有些xen的VPS里面会显示有xen。
4、执行：ifconfig 查看网卡，openvz的一般都是venet0:* ，xen、kvm的一般都是eth*。
5、通过VPS控制面板查看，像SolusVM、vePortal控制面板上都显示虚拟技术。
6、使用专门的软件：virt-what ，virt-what是一个判断当前环境所使用的虚拟技术的脚本，常见的虚拟技术基本上都能正常识别出来。

可以执行如下命令安装(需要安装好gcc、make)：

wget http://people.redhat.com/~rjones/virt-what/files/virt-what-1.15.tar.gz
tar zxvf virt-what-1.15.tar.gz
cd virt-what-1.15/
./configure
make && make install

再运行 virt-what ，脚本就会判断出当前环境所使用的虚拟技术，VPS侦探用手头上的VPS测试成功率还是比较高的。

腾讯云
[root@VM_223_239_centos ~]# virt-what
kvm

阿里云
[root@iZ285h4y5m0Z ~]# virt-what
xen
xen-hvm


Kernel

LXC：linux Container
Docker
Kubernetes

CoreOS
A new way to think about servers
CoreOS is Linux for massive server deployments

etcd Raft

Git
VirtualBox

https://www.packtpub.com/

坂村健 (Ken Sakamura)
TRON是一项开放式的实时操作系统内核设计项目，它是"The Real-time Operating system Nucleus"(实时操作系统内核)的缩写。


进程间通信IPC Inter-Process Communication
由于内存管理的一些机制，导致两个进程间并不能直接的进行通信(在独立的用户空间),因此我们需要利用一些介质来完成两个进程之间的通信。以下是常用的进程间通信方式。
# 管道(pipe)：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
# 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
# 信号量(semophore) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
# 消息队列(message queue) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
# 信号 (sinal) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
# 共享内存(shared memory) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
# 套接字(socket) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

要么单机的STM，分布式锁，数据库锁


一致性算法
Paxos Raft
随机抽样（RANSAC Random Sample Consensus）
http://en.wikipedia.org/wiki/ransac

一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一
致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。


企业集成模式:设计、构建及部署消息传递解决方案
http://www.enterpriseintegrationpatterns.com/




cPanel

linux container(LXC)


okhttp

JAVA 9
Jigsaw
http://openjdk.java.net/projects/jigsaw/quick-start

REPL
Read-Eval-Print Loop (REPL)
jshell jcmd jlink jdeprscan jrunscript

Nashorn JavaScript

Doclet API

JSON API
JIT(Just-in-time)
http://javamoney.github.io/

API Gateway
流量控制
熔断技术
微服务编排和调度
Monitor 服务健康度和质量
灾难备份
自动化性能伸缩
多租户和云化服务
资源调度
自动化运维

多租户技术(英语:multi-tenancy technology)或称多重租赁技术，是一种软件架构技术，它是在探讨与实现如何于多用户的环境下共用相同的系统或程序组
件，并且仍可确保各用户间数据的隔离性。

SOA服务化，消息中间件，远程调用中间件，缓存中间件，服务调度，监控，部署，网关



{
    "name": "some-app",
    "description": "description",
    "namespace": "default",
    "env": {
        "name": "local",
        "description": "the nodes of local environments",
        "nodes": [],
        "storages": []
    },
    "healthcheck_retry_times": 10,
    "healthcheck_interval": 10,
    "stack_provision_timeout": 1200000000000,
    "stack_destroy_timeout": 1200000000000,
    "stack_update_timeout": 1200000000000,
    "stack_scale_timeout": 1200000000000,
    "env_variables": [
        {
            "name": "INFRASTRUCTURE_PROVIDER",
            "value": "aws"
        },
        {
            "name": "SCRIPT_LOG_LEVEL",
            "value": "WARNING"
        }
    ],

   "deployments": [
        {
            "name": "backend-server",
            "image": "172.31.13.51/megaese/tomcat-server",
            "image_version": "1.8",
            "type": "Stateless",
            "description": "the backend-server component deployment information",
            "instance_count": 3,
            "require_resource": {
                "cpu": "300m",
                "memory": "512Mi"
            },
            "limit_resource": {
                "cpu": "500m",
                "memory": "1Gi"
            },
            "storage_mounts": [],
            "coloring_nodes": [
                "ip-172-31-10-103",
                "ip-172-31-9-252",
                "ip-172-31-14-200"
            ],
            "configurations": [
                "{\n\"httpPort\": 9527,\n\"stage\": \"test\"\n}"
            ],
            "initial_delay_seconds": 90,
            "healthcheck_retry_times": 30,
            "named_ports": [
                {
                    "name": "httpPort",
                    "port": 8080,
                    "is_host_port": false
                }
            ],
            "is_node_port": false,
            "node_port_policy": "default",
            "env_variables": []
        },

        {
            "name": "fontend-server",
            "image": "172.31.13.51/megaease/reactjs-web",
            "image_version": "1.8",
            "type": "Stateless",
            "description": "the reactjs-web component deployment information ",
            "instance_count": 1,
            "require_resource": {
                "cpu": "200m",
                "memory": "128Mi"
            },
            "limit_resource": {
                "cpu": "500m",
                "memory": "1Gi"
            },
            "storage_mounts": [],
            "coloring_nodes": [
                "ip-172-31-2-1"
            ],
            "configurations": [
                "{\n\"httpPort\": 8080,\n\"stage\": \"test\"\n}"
            ],
            "initial_delay_seconds": 60,
            "named_ports": [
                {
                    "name": "httpPort",
                    "port": 80,
                    "is_host_port": true
                }
            ],
            "is_node_port": true,
            "node_port_policy": "default",
            "env_variables": []
        }
    ],
    "healthchecker_image": "172.31.13.51/megaease/cmdagent",
    "healthchecker_image_version": "1.1"
}


CSS3 Grid Layout
Service Worker
HTML5 Web Worker
WebAssembly


JVMTI（Java Virtual Machine Tool Interface）
java.lang.instrument


RandomAccessFile


// ASYNC asynchronous
function PDFSign(params, fun) {
    console.log('1-----------------');
    fun();
}

function PDFSignFun(params) {
    var isFinish = false;
    PDFSign(params, function(){
        // isFinish = true;
        console.log('2-----------------');
    })
    while(!isFinish) {}
}


RBAC 基于角色的访问控制 (Role-Based Access Control)
https://en.wikipedia.org/wiki/NIST_RBAC_model
基于角色的访问控制(Role-Based Access Control)作为传统访问控制(自主访问，强制访问)的有前景的代替受到广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。

权限系统只有适合的，没有通用的，如果要通用的就基于RBAC就可以了，权限系统涉及的问题太多，效率也是问题，权限的继承也是问题，所以要根据自己的项目做才好


扁平化的权限设计

BDD
Behavior-driven development (https://en.wikipedia.org/wiki/Behavior-driven_development)

Azur Corporation
Sales Promotion Design.pdf

Microservices vs. Monolithic

libevent

Scratch
Sketch

Cocos2D
Unity3D
AndEngine
libGDX

SDN，软件定义网络(Software Defined Network, SDN )，是Emulex网络一种新型网络创新架构，是网络虚拟化的一种实现方式，其核心技术OpenFlow通过将网络设备控制面与数据面分离开来，从而实现了网络流量的灵活控制，使网络作为管道变得更加智能。
NFV，即网络功能虚拟化，Network Function Virtualization

比较并交换
CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术
int compare_and_swap (int* reg, int oldval, int newval) {
  ATOMIC();
  int old_reg_val = *reg;
  if (old_reg_val == oldval)
     *reg = newval;
  END_ATOMIC();
  return old_reg_val;
}

MVCC Multi-Version Concurrency Control 多版本并发控制

REPEATABLE READ
READ COMMITED
READ UNCOMMITED
SERIABLABLE

Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
Read committed (读已提交)：可避免脏读的发生。
Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

乐观锁
悲观锁
原子操作
互斥锁

互斥事件（exclusive event）
对立事件（opposite event）

事务处理 概念与技术 Jim Gray
transaction processing concepts and techniques pdf

Enterprise Integration Patterns : Designing, Building, and Deploying Messaging Solutions

第四范式：数据密集的科学发现

The Manager’s Path 作者 Camille Fournier
感知与响应 作者 Jeff Gothelf 和Joshua Seiden
Doing It - Management 3.0 Experiences 作者 Ralph van Roosmalen
Scaling Lean 作者 Ash Maurya
It's All Upside Down 作者 Paul McMahon

E-Science

Ken Thompson
Dennis Ritchie
Rob Pike
RISC之父John Cocke
Edsger Wybe Dijkstra

OLTP OLAT
TPC-A
TPC-B
TPC-C

ACID，指数据库事务正确执行的四个基本要素的缩写。包含:原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)。一个支持事务(Transaction)的数据库，必需要具有这四种特性，否则在事务过程(Transaction processing)当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。

CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency(一致性)、 Availability(可用性)、Partition tolerance(分区容错性)，三者不可得兼。

分布式系统的CAP理论:理论首先把分布式系统中的三个特性进行了如下归纳:
一致性(C):在分布式系统中的所有数据备份，在同一时刻是否同样的值。(等同于所有节点访问同一份最新的数据副本)
可用性(A):在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。(对数据更新具备高可用性)
分区容忍性(P):以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

CQRS
命令查询职责分离（CQRS，Command Query Responsibility Segregation）是一种应用架构模式，它会将应用分为两部分：查询部分（查看模型）和命令部分（写入模型）。每一部分都负责处理特定的操作集——分别也就是读取类型和写入类型。CQRS概念最初是由Greg Young提出和积极倡导的。它是CQS（命令-查询分离）理念的自然延伸，CQS理念由Bertrand Meyers提出，主张将方法分为命令和查询。CQRS使用了相同的原则，不过将其扩大到了整个系统中。

业务流程管理（Business Process Management，BPM）
业务流程改进（BPI Business process improvement,流程改进)自从流程再造思想诞生以来，对于"再造"的理解就存在不同的看法。且不说由Reengineering 衍生而来的Redesign(再设计)、Reorganization(再组织)、Reposition(再定位)、Revitalization(再生)等分支观点，以及由此激发的人们Re-everything(再造一切)的激情。单是能用来矫正或丰富BPR(Business process reengineering,流程再造)的定义的就有BPI(Business process improvement,流程改进)、BMR(Business model reengineering,生意模式再造)、BPM(Business process management,流程管理)和IPR(Industrial process reengineering)。
业务流程重组(Business Process Reengineering，BPR)最早由美国的Michael Hammer 和James Champy提出，在20世纪90年代达到了全盛的一种管理思想。强调以业务流程为改造对象和中心、以关心客户的需求和满意度为目标、对现有的业务流程进行根本的再思考和彻底的再设计，利用先进的制造技术、信息技术以及现代的管理手段、最大限度地实现技术上的功能集成和管理上的职能集成，以打破传统的职能型组织结构，建立全新的过程型组织结构，从而实现企业经营在成本、质量、服务和速度等方面的戏剧性的改善。

工作流管理、EAI、流程自动化、流程集成、流程建模、流程优化

钛合金


1.新增录入数据保存到录入库提交申报
2.审批通过
3.变更，复制要变更的数据，同时将录入库中原数据标记为不可用
    A.审批通过，原数据移到历史库
    B.审批失败，修改变更后重新提交
    C.删除变更数据，则还原原数据标记

1.新增录入数据
2.海关审批通过
3.变更时复制原数据（表头）记录变更次数
4.变更海关审批通过
5.将上一份海关审批通过数据移入到历史表

添加平台编号进行关联表体数据


固定电话校验
/^((\d{3,4}\-)|)\d{7,8}(|([-\u8f6c]{1}\d{1,5}))$/


json  _
image css url file -

XA
X/Open DTP

Microservice

Configuration Management 统一的配置管理
Centralized Configuration Management
Application Monitoring 性能监控/告警
Backup/Recovery 云部署管理 回滚/推送
Service Discovery 服务注册/发现
软负载均衡
Automatic Registration
Circuit Breaker 断路器
Chaos Monkey 主动破坏自身环境来发现弱点
Token Management
Message Queue
API Gateway Service （动态路由，监控，弹性，安全 dynamic routing, filter, monitoring, resiliency, security）
HTTP REST Client

Authentication (OAuth SSO Token)
Transformations
Logging
Caching
Rate-Limiting

Region Zone

线程池
断路器(自动熔断)、资源隔离、快速失败、自我修复
鉴权、限流、监控、日志、统计、灰度发布、流量转发、跨域、配置管理、过滤器、隔离、重试、容错、尝试恢复
配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性Token、全局锁、决策竞选、分布式会话和集群状态
幂等性
分布式事务（二段提交）
热更新
微服务编排引擎 Conductor
降级（本地缓存）
重试机制
熔断机制
负载均衡

API Gateway
服务间调用
服务发现
服务容错
服务部署
数据调用

https://www.consul.io/ (Service Discovery and Configuration)

TensorFlow


Netflix的开源文化与技术
http://netflix.github.io/

Netflix Conductor 流程的反转控制
Netflix Suro
Netflix Vectorflow 开源神经网络库

大数据

数据是无价的，为了向客户提供极致的服务，Netflix拥有一套完善的大数据技术生态系统用于用户数据的分析和挖掘。Netflix不仅使用Hadoop、Hive、Pig、Parquet、Presto以及Spark等被广泛采用的开源技术，同时还开发并贡献了一些其他的工具和服务。

Genie：专为Hadoop生态系统定制的一组REST-ful服务集合，用于管理作业和资源,它有两个关键的服务：Execution
Service和Configuration Serice。前者提供了REST-ful
API，用于提交和管理Hadoop、Hive以及Pig作业；后者是一个Hadoop资源的有效储存库，处理元数据的连接以及运行资源上的作业。
Inviso：对Hadoop作业和集群的性能进行详细而深入的剖析。
Lipstick：以一种清晰且可视化的方式展示Pig作业的工作流。
Aegisthus：是一个能够读取Cassandra SSTable的map/reduce程序，Netflix的大数据平台每天都会利用该工具从Cassandra中读取数据进行分析。

构建和交付工具

Nebula：Netflix开源的Gradle插件集合，可以让开发者更容易地使用Gradle构建、测试和部署项目。
Aminator：EBS AMI创建工具，支持CentOS/RedHat Linux镜像，利用该工具创建的镜像能够运行在EC2实例上。
Asgard：云部署和管理工具，该工具与Aminator配合使用，能够将打包后的AMI从开发者的桌面部署到AWS上。

通用的运行时服务和类库

Netflix的大部分服务都是以云平台为基础和技术栈，云平台由云服务、应用程序类库和应用容器组成，每一部分Netflix都有相应的技术保障。

Eureka：Netflix的云平台服务发现技术。
Archaius：分布式配置工具。
Ribbon：弹性且智能化的进程处理和服务通信。
Hystrix：提供单一服务调用所不具备的可靠性，提供运行时的延迟隔离和容错。
Karyon和Governator：JVM容器服务。
Prana sidecar：提供实例内代理，支持非JVM运行时。
Zuul：提供云部署周边的动态路由、监控、安全和弹性扩展等服务。
Fenzo：为云本地框架提供了更为高级的调度和资源管理功能，为装箱和集群自动扩展提供了插件实现，用户能通过自定义的插件实现自定义的调度优化。

数据持久化
面对每天数以万亿的行为数据，没有哪一种技术能够独自满足所有的用例，所有潜在的需求，为此Netflix不仅使用了Memcached和Redis等非持久化内存存储方案，还使用了可搜索的数据存储Elastic，以及高可用的数据存储Cassandra和MySQL。此外，Netflix还创建了一些其他的辅助工具：

Raigad和Priam：辅助Elastic和Cassandra集群的部署、管理、备份和恢复。
EVCache和Dynomite：用于大规模地使用Memcached和Redis。
Astyanax和Dyno客户端类库：便于更好地使用云端数据库。
分析、可靠性和性能
在任何一个公司的运营中遥测和指标都具有至关重要的作用，高效的性能指令能够让工程师快速地从大量指标中找出自己所需要的那部分从而更快更有效地做出关键决策。除此之外，成本管理和资源在云端使用情况的可视化服务也不可或缺，Netflix在这些方面使用的工具包括：

Atlas：时间序列遥测平台，每分钟接收超过10亿的指标
Edda：跟踪云端变化的服务
Spectator类库：让Java应用程序代码能够更好地与Atlas集成
Vector：以最小的代价获得高分辨率主机级指标
Ice：监控当前成本和云使用趋势，让工程师能够更好地掌控自己的应用程序在当前环境中的状态
Simian Army：Netflix实例的随机故障测试，用于验证可靠性

安全
对任意类型、任意规模的公司来说安全都是一件越来越重要的事情，Netflix为开源社区贡献了大量的安全工具和解决方案，主要分为两类，一类是能够让安全团队更有效地保护大型动态环境的运维工具和系统；一类是为现代分布式系统提供严格安全服务的安全基础设施组件。

Security Monkey：用于检测和保护大规模的AWS环境
Scumblr：利用因特网进行针对性的搜索定位特定的安全问题并调查
MSL：一个可扩展的、灵活的安全消息协议，可解决大量安全通信用例和需求

用户界面
世界各地的Netflix会员会通过TV、手机和桌面等各式各样的设备观看视频，为此Netflix使用了Node.js、React和RxJS等先进的UI技术构建富客户端应用程序。Netflix通过数据驱动的A/B测试实验新的理念，理解每一个功能特性的价值，从而持续地提升产品。此外，Netflix还使用了以下工具。

Falcor：允许应用程序把所有远端的数据源用一个单独的JSON Graph来表示，提高了数据抓取效率
Restify：一个基于Nodejs的REST应用框架，支持服务器端和客户端
RxJS：JavaScript的Reactive扩展库

服务注册中心	Zookeeper Spring Cloud Netflix Eureka
服务调用方式	RPC	REST API
服务网关	    Spring Cloud Netflix Zuul
断路器	    Spring Cloud Netflix Hystrix
分布式配置	Spring Cloud Config
服务跟踪	    Spring Cloud Sleuth
消息总线	    Spring Cloud Bus
数据流	    Spring Cloud Stream
批量任务	    Spring Cloud Task

RMI、Dubbo、Hessain、WebService、HTTP
Protobuf、Thrift、Kyro
gRPC

RESTful API
JSON-RPC

GraphQL

Hessian、spring httpinvoke

protobuf,json,xml,binary,Thrift

Binary-RPC(Remote Procedure Call Protocol，远程过程调用协议)
RMI(Remote Method Invocation，远程方法调用)
软负载均衡及容错
服务自动注册与发现

https://springcloud.cc/


LDAP是轻量目录访问协议，英文全称是Lightweight Directory Access Protocol，一般都简称为LDAP。
SAML即安全断言标记语言，英文全称是Security Assertion Markup Language。

OAUTH、OPENID、SAML、CAS做统一认证与授权时有什么区别，为何业界一股脑都使用oauth？
OPENID、SAML、CAS不能进行授 权的操作码？
我感觉好像都可以，还是因为OAUTH2.0协议在第三方调用开发上比较简单，比较轻量级，所以大家都采用oauth？
首先SSO和权限控制是两回事。
OpenID是IDP提供一个身份唯一标识把第三方的应用帐号绑定到唯一标识上，只起到了认证的作用。
SAML支持XACML协议进行权限控制。
CAS本身没有授权，也没有权限控制，但是CAS支持SAML，所以就支持了权限控制。
SAML协议较OAUTH来说确实比较复杂，但是功能也十分强大，支持认证，权限控制和用户属性。

DevOps 软件开发、运维和质量保证三个部门之间的沟通、协作和集成所采用的流程、方法和体系的一个集合。
SRE是指Site Reliability Engineering(网站可靠性工程)。网站可靠性工程师是软件工程师和系统管理员的结合，一个SRE工程师基本上需要掌握很多知识:算法，数据结构，编程能力，网络编程，分布式系统，可扩展架构，故障排除。

http://microservices.io/
http://www.enterpriseintegrationpatterns.com/
http://www.workflowpatterns.com/
https://martinfowler.com/
https://www.martinfowler.com/articles/serverless.html
Patterns of Enterprise Application Architecture
https://www.martinfowler.com/books/
Microservice Patterns

https://www.manning.com
https://www.packtpub.com
https://www.oreilly.com/
https://mitpress.mit.edu/
http://mitpress-ebooks.mit.edu/
https://read.douban.com
https://book.douban.com
http://www.informit.com
https://www.nostarch.com
https://www.objc.io
https://leanpub.com/

http://unpbook.com/
http://www.kohala.com/start/

https://salttiger.com/
http://www.foxebook.net/
https://coderprog.com/
https://avxhm.se/ebooks/programming_development/
http://www.allitebooks.com
http://domainlanguage.com

http://jdk.java.net

http://www.123rf.com.cn/

https://www.nginx.com/

区块链(Blockchain)是比特币的一个重要概念，区块链是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了过去十分钟内所有比特币网络交易的信息，用于验证其信息的有效性(防伪)和生成下一个区块。该概念在中本聪的白皮书中提出，中本聪持有第一个区块，即"创世区块"。

Vivaldi

1.“开-闭”原则(OCP)
Software entities should be open for extension, but closed for modification.
对扩展开放，对修改封闭。
2.里氏代换原则(LSP)
凡是基类适用的地方，子类一定适用。
3.依赖倒转原则(DIP)
要依赖抽象，不要依赖具体。
4.迪米特法则(LoD)
一个对象应该对其他对象有尽可能少的了解。
5.接口隔离原则(ISP)
使用多个专门的接口比适用单一的接口要好。
6.合成/聚合复用原则(CARP)
要尽量使用合成/聚合，尽量不要使用继承。

Serverless

CRUD是指在做计算处理时的增加(Create)、读取(Retrieve)(重新得到数据)、更新(Update)和删除(Delete)几个单词的首字母简写。

http://www.infoq.com/cn/news/2015/12/soa-v-microservices
http://www.adam-bien.com/roller/abien/entry/the_difference_between_soa_and
https://my.oschina.net/agileai/blog/919970

使用Baas和Faas是Serverless应用的基本特征，符合这两个基本特征的应用可称为Serverless应用。
Baas(Backend as a Service，后端即服务，使用了公共云提供的对象存储和数据库服务)。
Faas(Functions as a Service, 函数即服务， 使用Lambda框架)。

AI应用用到了对象存储和数据库，将来或许还会用到消息队列。直观感觉是在用PaaS，其实是用BaaS。
PaaS和BaaS的区别在于: PaaS需要参与应用的生命周期管理，BaaS则仅仅提供应用依赖的第三方服务。典型的PaaS平台需要提供手段让开发者部署和配置应用。例如自动将应用部署到Tomcat容器中。并管理应用的生命周期。BaaS不包含这些内容。BaaS只以API的方式提供应用依赖的后端服务，例如数据库和对象存储。BaaS可以是公共云服务商提供。

https://letsencrypt.org/

SRE

http://xiangli.co/

Payload

http://bliki.net/

https://www.liki.com/
http://www.galeriedujouet.com/
https://rocail.liki.com/
https://www.etsy.com/
https://lidia-r-joailliere.liki.com/

https://www.24tidy.com/

QUIC(Quick UDP Internet Connection)是谷歌制定的一种基于UDP的低时延的互联网传输层协议。
UDT 基于UDP的数据传输协议(UDP-based Data Transfer Protocol，简称UDT)是一种互联网数据传输协议。

Dijkstra算法

http://blog.sina.com.cn/s/articlelist_2734614830_0_1.html


P2SP
就是下载不再象传统方式那样只能依赖服务器，内容的传递可以在网络上的各个终端机器中进行。P2SP除了包含P2P以外，P2SP的"S"是指服务器。P2SP有效地把原本孤立的服务器和其镜像资源以及P2P资源整合到了一起。

每一个行为背后实际上有一股未知的力量在影响着我们。

NewSQL


消息ID
排序组合条件成字符串
SSH
http://www.jcraft.com/jsch/
http://www.jcraft.com/jzlib/
https://github.com/cverges/expect4j
http://www.cnblogs.com/ylqmf/archive/2012/06/28/2567811.html

MurmurHash

P 问题和 NP 问题
程序员和商人的思想差距太大了

游戏引擎架构

271制度，20%的人调薪在15%以上，70%在5-10%之间，10%的人不给调薪，调薪制度主要向基层倾斜，总监以上级别有股权的不予调薪

MySQL router
vitess
Maxscale
Atlas
kingshard
OneProxy
Mango
Sharding-JDBC
atlas
amoeba for mysql
cobar alibaba

Vector Clock算法

SQL语言共分为四大类：数据查询语言DQL，数据操纵语言DML，数据定义语言DDL，数据控制语言DCL。

事务补偿

TCC
Try：预留业务资源
Confirm：确认执行业务操作
Cancel：取消执行业务操作

2PC，2 Phase Commit


未来世界的幸存者
C语言核心技术

异常流行幻象与群众疯狂/困惑之惑（[台湾]财讯出版社，2007，ISBN 9789867084385）
下一个大泡泡（中国社会科学出版社，2005，ISBN 9787500452300）

Zab 协议
ZAB（ZooKeeper Atomic Broadcast ） 全称为：原子消息广播协议；
Epoch指的是一个特定的时间:1970-01-01 00:00:00 UTC。

状态机
有限状态机
无限状态机

一致性区分,对于一致性CAP原则和关系型数据库中ACID的一致性两者明显有区别。

分布式领域CAP理论，
Consistency(一致性), 数据一致更新，所有数据变动都是同步的
Availability(可用性), 好的响应性能
Partition tolerance(分区容错性) 可靠性
定理：任何分布式系统只可同时满足二点，没法三者兼顾。

关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区：
Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。
Consistency一致性. 在事务开始或结束时，数据库应该在一致状态。
Isolation隔离层. 事务将假定只有它自己在操作数据库，彼此不知晓。
Durability. 一旦事务完成，就不能返回。

前者是对副本冗余的处理。即存在多个拷贝的时候，拷贝和拷贝之间的一致性。
而后者是集中于事务，对于事务进行前后的数据库状态一致性。

拜占庭将军问题 Byzantine fault tolerance
https://en.wikipedia.org/wiki/Byzantine_fault_tolerance
拜占庭将军问题（Byzantine failures）又称两军问题，是由莱斯利·兰伯特提出的点对点通信中的基本问题。
含义是在存在消息丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。因此对一致性的研究一般假设信道是可靠的，或不存在本问题。

实时事件处理分解为六种操作 —— 筛选、关联、分类、转换、注解和决策

数据传递形式分为三大类：
最多一次（At-most-once）：消息可能会丢失，这通常是最不理想的结果。
最少一次（At-least-once）：消息可能会再次发送（没有丢失的情况，但是会产生冗余）。在许多用例中已经足够。
恰好一次（Exactly-once）：每条消息都被发送过一次且仅仅一次（没有丢失，没有冗余）。这是最佳情况，尽管很难保证在所有用例中都实现。

对于产生海量数据且不间断的数据源，又要求对用户提供秒级的实时响应，这就是实时计算的主要场景。

实时计算的概念
实时计算一般都是针对海量数据进行的，一般要求为秒级。实时计算主要分为两块:数据的实时入库、数据的实时计算。

实时计算的相关技术
主要分为三个阶段（大多是日志流）:
数据的产生与收集阶段、传输与分析处理阶段、存储对对外提供服务阶段

1.数据实时采集
目前的产品：Facebook的Scribe、LinkedIn的Kafka、Cloudera的Flume，淘宝开源的TimeTunnel、Hadoop的Chukwa等，均可以满足每秒数百MB的日志数据采集和传输需求。
2.数据实时计算
在流数据不断变化的运动过程中实时地进行分析，捕捉到可能对用户有用的信息，并把结果发送出去。
Yahoo的S4：S4是一个通用的、分布式的、可扩展的、分区容错的、可插拔的流式系统，Yahoo开发S4系统，主要是为了解决：搜索广告的展现、处理用户的点击反馈。
Twitter的Storm：是一个分布式的、容错的实时计算系统。可用于处理消息和更新数据库（流处理），在数据流上进行持续查询，并以流的形式返回结果到客户端（持续计算），并行化一个类似实时查询的热点查询（分布式的RPC）。
Facebook 的Puma：Facebook使用puma和HBase相结合来处理实时数据，另外Facebook发表一篇利用HBase/Hadoop进行实时数据处理的论文（ApacheHadoop Goes Realtime at Facebook），通过一些实时性改造，让批处理计算平台也具备实时计算的能力。
早期的：IBM的Stream Base、 Borealis、Hstreaming、Esper
3.实时查询服务
半内存：使用Redis、Memcache、MongoDB、BerkeleyDB等内存数据库提供数据实时查询服务，由这些系统进行持久化操作。
全磁盘：使用HBase等以分布式文件系统（HDFS）为基础的NoSQL数据库，对于key-value引擎，关键是设计好key的分布。
全内存：直接提供数据读取服务，定期dump到磁盘或数据库进行持久化。

Akka
http://akka.io/
RXJava

WebSocket

现代密码学
自动机

InfiniBand

Mesos
Docker


https://daniel.haxx.se/http2/

https://javaee.github.io/
https://javaee.github.io/hk2/
https://javaee.github.io/grizzly/
http://vertx.io/

http://dubbo.io/
https://grpc.io

http://qpid.apache.org/
http://thrift.apache.org/

Lambda
Java8 Parallel Stream API

exe4j
instal4j

sigar
http://sigar.hyperic.com/

TFS
mogileFS
FastDFS

GridFS >16M
MongoDB

对于小文件问题，Hadoop本身也提供了几个解决方案，分别为：Hadoop Archives，Sequence file和CombineFileInputFormat。
http://blog.cloudera.com/blog/2009/02/the-small-files-problem/

https://wrapper.tanukisoftware.com/doc/english/download.jsp

The Art of UNIX Programming
算法:C语言实现(第1～4部分)基础知识、数据结构、排序及搜索(原书第3版)

http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-088-introduction-to-c-memory-management-and-c-object-oriented-programming-january-iap-2010/index.htm#features

Implementing Lock-Free Queues
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.8674&rep=rep1&type=pdf

ABA problem


Strong Reference 强引用 强引用是使用最普遍的引用。
Weak Reference 软引用 当没有指向它的强引用时会被GC回收
Soft Reference，只当临近OOM时才会被GC回收
Phantom Reference，主要用于识别对象被GC的时机，通常用于做一些清理工作

强引用（StrongReference）
强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常
终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。

软引用（SoftReference）
如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以
被程序使用。软引用可用来实现内存敏感的高速缓存（下文给出示例）。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列
中。

弱引用（WeakReference）
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管
当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

虚引用（PhantomReference）
“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何
时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收
器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。

ReferenceQueue queue = new ReferenceQueue ();
PhantomReference pr = new PhantomReference (object, queue);

程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用
的对象的内存被回收之前采取必要的行动。


select poll epoll

柯里化 Currying
柯里化(Currying)是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。

谢蔡六郎—谢国忠、蔡洪斌、胡祖六、郎咸平；
三纲五常—樊纲、易纲、胡鞍钢、张五常；
林海张杨—林毅夫、海闻、张维迎、杨小凯；
李白杜甫—李稻葵、白重恩、邹恒甫；
国富国强—谭国富、田国强。

贝兰克梵
加里·科恩(Gary Cohn)

------------------------------------------------------------------------------------------------------------------------
PostgreSQL

MQTT
http://mqtt.org/


background-color: #159957;
background-image: linear-gradient(120deg, #155799, #159957);

https://www.raspberrypi.org/

Windows 10 Universal Windows Platform
https://comentsys.wordpress.com/2015/05/31/windows-10-universal-windows-platform-tutorials/
https://mva.microsoft.com/
https://microsoft.github.io/
http://edi.wang/
https://skylark-workshop.xyz

https://www.unqlite.org/
https://www.sqlite.org/

https://stackoverflow.com/

GPL, LGPL, BSD, MIT, Apache, GNU

Graphics Library

POSIX 表示可移植操作系统接口(Portable Operating System Interface ，缩写为 POSIX )，POSIX标准定义了操作系统应该为应用程序提供的接口标
准，是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。


W.Richard Stevens (2009-07-08 10:13:11)

1999 年9月1日，著名的TCP/IP,UINX技术专家，作家和教育家 W.Richard Stevens与 世长辞，英年早逝，享年48岁，先生的离去，是计算机界的重大损失，更
读者的莫大的遗憾。先生的为人处事，网上的评价足以说明一切————一个程序 员做到W.Richard.Stevens那个份上，做到逝世后还能叫全世界的顶级hacker们专
门著文怀念，但生前却不曾著文攻击，想想看，那是一种什么样的境界，那是一份什么样的淡然。
如今算来，Richard Stevens先生已经离我们而去整整8年，但先生留下的6本bible级的著作《Unix环境高级编程》《Unix网络编程 卷1,2》和
《TCP/IP详解 卷1,2,3》却一直伴随我们左右。想想自己接触Linux/Unix的这段日子里，正是不断从先生的文字里汲取营养，领我进入Unix编程世界中去。先生
的著作行文流畅、语言毫不晦涩，真可谓字字珠玑，可以毫不夸张地说，读其书丝毫不是一种负担，而是一种享受。正如孟岩所说“Richard Stevens以他的写作风格
和作品，在TCP/IP编程领域竖立起一座丰碑，令其他作者高山仰止，心向往之”。想必每一个有志于unix编程的朋友，读先生的书定会有相见恨晚之感。
感恩W.Richard Stevens，先生您将永远活在我们读者的心里！


http://www.kohala.com/start/
2006年3月  《UNIX环境高级编程（第2版）》英文影印版出版
2006年5月  《UNIX环境高级编程（第2版） 》中译版出版

UNIX Network Programming, Volume 1, Second Edition: Networking APIs: Sockets and XTI, Prentice Hall, 1998, ISBN 0-13-490012-X.
UNIX Network Programming, Volume 2, Second Edition: Interprocess Communications, Prentice Hall, 1999, ISBN 0-13-081081-9.
2009年11月 《UNIX网络编程 卷1：套接字联网API（英文版•第3版）》《UNIX网络编程 卷2：进程间通信（英文版•第2版）》出版
2010年6月  《UNIX网络编程 卷1：套接字联网API（第3版）》《UNIX网络编程 卷2：进程间通信（第2版）》中译版出版

TCP/IP Illustrated, Volume 1: The Protocols, Addison-Wesley, 1994, ISBN 0-201-63346-9.
TCP/IP Illustrated, Volume 2: The Implementation, Addison-Wesley, 1995, ISBN 0-201-63354-X.
TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX Domain Protocols, Addison-Wesley, 1996, ISBN 0-201-63495-3.
2010年3月  《TCP/IP详解 卷1：协议（英文版）》、《TCP/IP详解 卷2：实现（英文版）》和《TCP/IP详解 卷3：T/TCP、HTTP、NNTP及UNIX域协议（英文版） 》三卷出版

Advanced Programming in the UNIX Environment, Addison-Wesley, 1992, ISBN 0-201-56317-7.
UNIX Network Programming, Prentice Hall, 1990, ISBN 0-13-949876-1.

envy note 8


Multi-homing

possibly,probably,perhaps,maybe
additionally, in addition, besides, moreover, furthermore, admittedly, though, even though, while

http://luajit.org/

迪克斯加算法(Dijkstra)

“最大的自私就是无私”
“人生攒满了回忆就是幸福”
“在这个世界中，每天都有新的东西出现，充分满足了人类性格基因中喜新厌旧的需求”

National data 国家数据
http://data.stats.gov.cn/

信用
环比 同比 定基
布雷顿森林体系

CDO
担保债务凭证(Collateralized Debt Obligation，简称CDO)，资产证券化家族中重要的组成部分。它的标的资产通常是信贷资产或债券。

CDS
信用违约互换(Credit Default Swap,CDS)又称为信贷违约掉期，也叫贷款违约保险，是目前全球交易最为广泛的场外信用衍生品。

huishuwu.com
fanshu.net
huishu.net
yusan.net
zaodu.net
yishe.net

ETL:Extraction-Transformation-Loading

http://scm-blog.com
http://www.wangjianshuo.com
http://home.wangjianshuo.com/cn/
http://www.mindmeters.com

The format of the version-string is $MAJOR.$MINOR.$SECURITY.$PATCH
$MAJOR is the version number that is incremented for a major release, for example JDK 9, which contains significant new
features as specified by the Java SE platform specification. A major release contains new features and changes to
existing features, which are planned and announced well in advance.

$MINOR is the version number that is incremented for each minor update, such as bug fixes, revisions to standard APIs,
or implementation of features outside the scope of the relevant platform specifications.

$SECURITY is the version number that is incremented for a security-update release, which contains critical fixes,
including those necessary to improve security.
$PATCH is the version number that is incremented for a release containing security and high-priority customer fixes that
have been tested together.

https://docs.oracle.com/javase/9/index.html

https://www.merriam-webster.com/

RFID
射频识别，RFID(Radio Frequency Identification)技术，又称无线射频识别，是一种通信技术，俗称电子标签。可通过无线电讯号识别特定目标并读写相关
数据，而无需识别系统与特定目标之间建立机械或光学接触。

贸易逆差 Unfavorable Balance 0f Trade
贸易顺差 Favorable Balance 0f Trade

上层建筑
上层建筑是指建立在一定经济基础之上的以生产关系为核心的社会关系之和。它包括阶级关系(基础关系)、维护这种关系的国家机器、社会意识形态以及相应政治法律
制度、组织和设施等。 上层建筑与经济基础对立统一。

Gartner's Hype Cycle（技术成熟度曲线）

https://micro-editor.github.io


Programmable
Assembly
Assemble
Mountable
Package

Messenger
Assembler

Visualization
Definition
Resource
Repository

store storage
serve service
assemble assembly
visible visualization visualize
disable
overview

hybrid
stack
support



你不可能了解一件事物而不改变它——这就是量子物理的基本哲学。好比有一碗水放在你面前，当你舀了一小勺送到自己嘴里想试试冷热时，这碗水就已经不是先前那碗
了。对于一个微观的粒子，观测的结果既有一定的随机性，观测行为本身又会破坏粒子原来的状态，让你永远不可能知道粒子本来的状态是什么——这就是量子不可克隆
原理：你不能够复制一个未知的量子态，而不改变量子态本身。

量子加密通常的信息载体是光子，也就是组成光的基本粒子。我们把一个比特的信息加载在一个光子上，然后把光子一个个发出去。接收方在所有收到的光子中取出一部
分，跟原本发送的信息比较。如果准确无误，就说明没有窃听者存在，信息传输是安全的。

为了达到量子加密的目的，甲方首先产生许多纠缠在一起的光子。然后他把纠缠光子中的一端发给乙方，而自己保留另一端。乙方收到甲方发来的光子，先把保密的信息
写进光子中，然后通过一个光放大器把信号放大一万倍。

然而，由于量子态是不能被克隆的，而信号放大的本质和克隆相同，因此也就不存在理想的放大器——任何放大器都会引入一定的噪声，使得原本的状态被破坏。每一个
被放大的信号光子都会伴随着一千万个完全不相关的噪声光子。这些噪声光子把原本的纠缠态完全破坏。乙方再把包含巨大噪声的信号发还给甲方。甲方把乙方送回的信
号跟自己保存的纠缠光子的另一端进行作用，乙方写进光子的保密信号就会神奇地显现出来。而窃听者看到的，仅仅是从乙方发来的巨大噪声。

甲方之所以能够从噪声中恢复乙方写入的信号，就是利用了纠缠的关联性——即使最后纠缠被完全破坏了，残留的关联性仍然能够战胜巨大的噪声。由于窃听者并不拥有
纠缠的另一端，因此是无法解码的。

所以说，你必须先制造出两个互相纠结的光子，然后输入加密信息后再发送出去一个光子，所以来说，量子保密通讯还是无法实现超光速通讯的


MNV*
https://www.w3ctech.com/topic/1827
使用nativeView来代替目前html的view，而交互逻辑依然可以使用viewModel、virtual Dom或者controller来实现

理查德·塞勒
反常行为、经济人假设、禀赋效应、跨期选择、心理账户和股票市场

位运算

https://www.nngroup.com/

CIIA
注册国际投资分析师 Certified International Investment Analyst，CIIA 资格是全球投资分析领域最具国际影响力的专业资格之一，由注册国际投资分
析师协会Association of Certified International Investment Analyst, ACIIA统一管理。

笛卡尔积
等值连接

https://www.w3resource.com

Linux Kernel Development

矩阵乘法
蒙特卡罗方法
正态分布（Normal distribution）又名高斯分布（Gaussian distribution）
原子钟
双中子星合并产生引力波

垃圾回收算法手册 自动内存管理的艺术
信息论基础(原书第2版)
信息论与编码理论

莱洛三角形

http://www.rfc-editor.org/rfc-index.txt
http://www.mbalib.com

http://richardlee/torvalds-says-linux.mp3

https://herbertograca.com/2017/10/05/event-driven-architecture/?imm_mid=0f735b&cmp=em-prog-na-na-newsltr_20171014
https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/
https://herbertograca.com/2017/01/26/microservices-architecture/

https://8thlight.com/blog/

http://www.hzbook.com/

http://haoci.com/
http://sui.com/
http://nucc.com/

https://www.digitaling.com/
http://www.goodzilla.cn/

http://www.worldbank.org/

http://sortbenchmark.org/

http://www.openliberty.org/
https://www.freshworks.com/
https://freshdesk.com/
https://www.lightbend.com/
https://www.pubnub.com/


腾讯打破全球计算奥运4项纪录，98.8秒完成100TB数据排序 2016年11月10日17:57

腾讯科技讯 11月10日，Sort Benchmark全球排序竞赛公布2016年最终成绩，腾讯云大数据联合团队用时不到99秒（98.8秒）就完成100TB的数据排序，打破阿里
云去年创造的329秒的纪录。在更早前，百度创造的纪录是716秒，Hadoop的纪录是4222秒。
在这次竞赛中，腾讯云数智分布式计算平台，夺得Sort Benchmark大赛GraySort和MinuteSort的冠军，总共创造四项世界纪录，将去年阿里云的纪录整体提高
2倍到5倍。

每年全球顶尖公司和学术机构都会来参加该赛事，以评估软硬件系统架构能力及最新研究成果。这项赛事包括四项比赛，腾讯云大数据联合团队参加的是含金量最高的
GraySort和MinuteSort两项排序竞赛，重点评测大规模分布式系统的软硬件架构能力及平台的计算效率，以上两项比赛均包括Indy（专用目的排序）和
Daytona（通用目的排序）两个子项。数智一举夺得上述四个子项的冠军，总体将去年的纪录提高2倍到5倍。

GraySort竞赛比拼的是如何在最短的时间内，将总共100TB，一共1万亿条无序的100字节纪录，按照从小到大的顺序进行排序。数智用时98.8秒完成100TB的数据排
序，即每分钟完成60.7TB的数据排序，去年冠军的纪录为18.2TB/分钟。MinuteSort竞赛，比拼的是在1分钟之内能够完成多少数据量的排序。数智的成绩为1分钟
完成55TB的排序，去年冠军的纪录是11TB，数智将这一数据量提升5倍。


FROM_UNIXTIME(unix_timestamp,format)

%M 月名字(January……December)
%W 星期名字(Sunday……Saturday)
%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。)
%Y 年, 数字, 4 位
%y 年, 数字, 2 位
%a 缩写的星期名字(Sun……Sat)
%d 月份中的天数, 数字(00……31)
%e 月份中的天数, 数字(0……31)
%m 月, 数字(01……12)
%c 月, 数字(1……12)
%b 缩写的月份名字(Jan……Dec)
%j 一年中的天数(001……366)
%H 小时(00……23)
%k 小时(0……23)
%h 小时(01……12)
%I 小时(01……12)
%l 小时(1……12)
%i 分钟, 数字(00……59)
%r 时间,12 小时(hh:mm:ss [AP]M)
%T 时间,24 小时(hh:mm:ss)
%S 秒(00……59)
%s 秒(00……59)
%p AM或PM
%w 一个星期中的天数(0=Sunday ……6=Saturday ）
%U 星期(0……52), 这里星期天是星期的第一天
%u 星期(0……52), 这里星期一是星期的第一天
%% 一个文字“%”。

例子：
SELECT FROM_UNIXTIME(1234567890, '%Y-%m-%d %H:%i:%S')

------------------------------------------------------------------------------------------------------------------------
MYSQL自带函数计算给定的两个日期的间隔天数

有两个途径可获得
1、利用TO_DAYS函数
select to_days(now()) - to_days('20120512')

2、利用DATEDIFF函数
select datediff(now(),'20120512')
参数1 - 参数2 等于间隔天数

3、利用TIMESTAMPDIFF函数
计算两日期时间之间相差的天数，秒数，分钟数，周数，小时数，这里主要分享的是通过MySql内置的函数 TimeStampDiff() 实现。

函数 TimeStampDiff() 是MySQL本身提供的可以计算两个时间间隔的函数，语法为：
TIMESTAMPDIFF(unit, datetime_expr1, datetime_expr2)

返回日期或日期时间表达式datetime_expr1 和datetime_expr2the 之间的整数差。其中unit单位有如下几种，分别是：FRAC_SECOND (microseconds),
SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR 。该参数具体释义如下：

FRAC_SECOND 表示间隔是毫秒
SECOND      秒
MINUTE      分钟
HOUR        小时
DAY         天
WEEK        星期
MONTH       月
QUARTER     季度
YEAR        年

例如：
#计算两日期之间相差多少周
SELECT TIMESTAMPDIFF(week,'2011-09-30','2015-05-04');
#计算两日期之间相差多少天

SELECT TIMESTAMPDIFF(day,'2011-09-30','2015-05-04');
另外计算两日期或时间之间相差多少天还可以使用 to_days 函数，但是该函数不用于阳历出现(1582)前的值，原因是当日历改变时，遗失的日期不会被考虑在内。
因此对于1582 年之前的日期(或许在其它地区为下一年 ), 该函数的结果实不可靠的。具体用法如：

TO_DAYS(end_time) - TO_DAYS(start_time);

#计算两日期/时间之间相差的秒数：
SELECT TIMESTAMPDIFF(SECOND,'2011-09-30','2015-05-04');
另外还可以使用 MySql 内置函数 UNIX_TIMESTAMP 实现，如下：
SELECT　UNIX_TIMESTAMP(end_time) - UNIX_TIMESTAMP(start_time);　

#计算两日期/时间之间相差的时分数：　
SELECT TIMESTAMPDIFF(MINUTE,'2011-09-30','2015-05-04');

另外还可以如下实现：
SELECT　SEC_TO_TIME(UNIX_TIMESTAMP(end_time) -　UNIX_TIMESTAMP(start_time));

------------------------------------------------------------------------------------------------------------------------
InnoDB 全文索引

SELECT * FROM TEST T WHERE MATCH(TEST_NO, TEST2_NO) AGAINST('XXX');

------------------------------------------------------------------------------------------------------------------------
http://survivor.ruanyifeng.com/

http://www.istockphoto.com/
http://www.veer.com/
http://www.xianyou.tv/
http://www.3g-sys.com/

http://www.kaiyuan.net/
https://www.vcg.com/
https://yarnpkg.com/zh-Hans/

1.容器服务
分布式自愈合
深度优化
横向扩容
基础设施可替换
全流程自动化(DevOps)
健康巡检

2.微服务架构
快速发布
可视化管理
组件积累
微服务化
服务发现

3.API网关
解放生产力
按需计费
规模大性能高
保防同行
系统三化
多端统一

4.监控预警
系统性能监控
健康巡检
文件备份
业务指标阀值设置
定时任务
异常报警

用户权限管理系统
关系型数据库管理系统
持续集成
消息系统
代理服务器
配置中心
服务发现
项目管理

服务编排

Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday

January
February
March
April
May
June
July
August
September
October
November
December


vi /etc/crontab
0  0  1  *  *  root  ntpdate  ntp1.aliyun.com

------------------------------------------------------------------------------------------------------------------------
executeLogin onLoginSuccess onLoginFailure onAccessDenied
doGetAuthenticationInfo
doGetAuthorizationInfo

------------------------------------------------------------------------------------------------------------------------

当你试图解决一个问题时，那么新的问题就会诞生，这样简单的逻辑就慢慢变得复杂了。
没有最优，只有更优。

http://0pointer.de/blog/projects/the-biggest-myths.html

阿基米德

https://uispace.net
https://freebiesbug.com
https://envato.com
https://www.mockuuups.com
https://proto.io
https://cn.fotolia.com
https://www.patpat.com/
https://www.moo.com

EnumMap
Optional

https://www.trip.com/
https://www.tianxun.com/
http://www.xiaozhu.com/
http://www.vision.com/
https://www.spotify.com/
http://www.slideshare.net/
https://www.linkedin.com/
https://www.fancy.com/
https://www.wish.com/
http://www.maijia.com/
https://www.limin.com/
http://www.qianbao.com/
http://www.wangyin.com/
https://www.ant.com/
https://www.godaddy.com/
http://www.go.co/
https://www.thoughtworks.com
https://zaozuo.com/
http://www.muji.com.cn/
http://www.ikea.com/

yijinyuan.com
------------------------------------------------------------------------------------------------------------------------
SERVICES & SUPPORT

Access Token

Passport
Dashboard
Favorite
Shopping Mall

Product Promotions

Consumer
Merchant
Product/Goods
Coupons
Campaign

Description
Product Details

Shopping
Cart
Cart items
Order
Order items
Payment
Subtotal
Payment method

Brand
Option
SKU (Stock Keeping Unit)
Length
Width
Height
Weight
Price
In Stock
Main Image URL
Extra Image URL
Product Name
Quantity (Qty)
Tags
Optional Attributes
Size
Color
MSRP (Manufacturer Suggested Retail Price)
Landing Page URL
UPC
Brand Image
Inventory
Total quantity
Sold
Category


Shipping Cost
Shipping Time

Security
Authentication
Authorization

Shipping Addresses

Buy
Purchases

Wish List

Followers
Following

On Sale


Shipping calculation
Free Shipping

Shipping profile
Ships to
Shipping location

HS Code
Country of Manufacture


Return & Exchange
Return Policy
Policy description

No returns
This item is non-returnable.

Final sale and no returns
This item is final sale and non-returnable.

15 day returns
If for any reason you are not happy with your purchase, you may return the item(s) within 15 days of receiving the order for Fancy Credit of the merchandise cost.
Please note that we cannot accept returns on monogrammed, personalized, special-order items, or on items damaged through normal wear and tear.

30 day returns
If for any reason you are not happy with your purchase, you may return the item(s) within 30 days of receiving the order for Fancy Credit of the merchandise cost.
Please note that we cannot accept returns on monogrammed, personalized, special-order items, or on items damaged through normal wear and tear.

Custom day returns
If for any reason you are not happy with your purchase, you may return the item(s) within {custom_return_policy_days} days of receiving the order for Fancy Credit of the merchandise cost.
 Please note that we cannot accept returns on monogrammed, personalized, special-order items, or on items damaged through normal wear and tear.

Status
Active
Mark as sold out

Store details
Store name
Tagline
Description

Store logo
Logo image

Store Header

Size Guide

Social
Footer links

Partners

make future
make possible

order history

Access your purchases and view your order history
------------------------------------------------------------------------------------------------------------------------

atomikos、bitronix、narayana
仅atomikos支持XA和TCC两种机制，bitronix、narayana仅支持XA机制

https://www.bytesoft.org/
------------------------------------------------------------------------------------------------------------------------

性爱最初是繁衍后代的从什么时候起变成娱乐的一部分

相互性的需要
------------------------------------------------------------------------------------------------------------------------
http://www.swftools.org/
xpdf-chinese-simplified

tdt.net
xhv.net
thinkin.net
thing
think






























dispatch
service
terminal
list
view

payload

request context
request data
request body
response context
response data
response body

profile
module

component-scan
base-package
property-placeholder
resource-pattern

------------------------------------------------------------------------------------------------------------------------

https://www.ebay.com/
https://www.fancy.com/
https://www.wish.com/

buy/purchase
pay

common
service
infrastructure

CloudKit
  Shopping
    Explore
    Search (Search for anything #Advanced)
    Add to Cart
    Buy Now
    View Your Cart
    View Your Orders
    Proceed to Checkout
    Place your order

  Security
    Authentication
    Authorization
    Is Access Allowed
    On Access Denied
    Get User Permissions

  Merchant
    Orders
      View Orders
    Products
      Add Product
      View Products
      Export
      Import
  Account
    Log In/Sign In
    Log Out/Sign Out
    Sign Up
    Join
  Captcha



Cart
Order
    Open
    All
    Completed
    Cancelled
    Affiliate
Product
    All Products
    Active
    Inactive
    Sold Out
    Expired
    Awaiting Approval
    On Sale
Category
    All Categories
    Antiques
    Art
    Baby
    Books
    Business & Industrial
    Cameras & Photo
    Cell Phones & Accessories
    Clothing, Shoes & Accessories
    Coins & Paper Money
    Collectibles
    Computers/Tablets & Networking
    Consumer Electronics
    Crafts
    Dolls & Bears
    DVDs & Movies
    Motors
    Entertainment Memorabilia
    Gift Cards & Coupons
    Health & Beauty
    Home & Garden
    Jewelry & Watches
    Music
    Musical Instruments & Gear
    Pet Supplies
    Pottery & Glass
    Real Estate
    Specialty Services
    Sporting Goods
    Sports Mem, Cards & Fan Shop
    Stamps
    Tickets & Experiences
    Toys & Hobbies
    Travel
    Video Games & Consoles
    Everything Else
User
Role
Permission
Resource
Message


Configuration
Setting

Dashboard
Console
Terminal

FAQ
About
Get the app
Help
Privacy
Terms
Contact


------------------------------------------------------------------------------------------------------------------------
JVM上的随机数与熵池策略
http://ifeve.com/jvm-random-and-entropy-source/
http://blog.csdn.net/u011627980/article/details/54024974
https://segmentfault.com/a/1190000009039011
https://wiki.apache.org/tomcat/HowTo/FasterStartUp

Linux内核采用熵来描述数据的随机性。熵(entropy)是描述系统混乱无序程度的物理量，一个系统的熵越大则说明该系统的有序性越差，即不确定性越大。在信息学
中，熵被用来表征一个符号或系统的不确定性，熵越大，表明系统所含有用信息量越少，不确定度越大。

计算机本身是可预测的系统，因此，用计算机算法不可能产生真正的随机数。但是机器的环境中充满了各种各样的噪声，如硬件设备发生中断的时间，用户点击鼠标的时
间间隔等是完全随机的，事先无法预测。Linux内核实现的随机数产生器正是利用系统中的这些随机噪声来产生高质量随机数序列。

内核维护了一个熵池用来收集来自设备驱动程序和其它来源的环境噪音。理论上，熵池中的数据是完全随机的，可以实现产生真随机数序列。为跟踪熵池中数据的随机
性，内核在将数据加入池的时候将估算数据的随机性，这个过程称作熵估算。熵估算值描述池中包含的随机数位数，其值越大表示池中数据的随机性越好。

------------------------------------------------------------------------------------------------------------------------
响应式编程 简称RP(Reactive Programming)
响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进
行传播。
------------------------------------------------------------------------------------------------------------------------
通胀 经济发展的假像
无论鼓吹的多么伟大的体制,总是存在着上等人,中等人与下等人的.这是人类予生具来的个体差异所决定的事实.不同的只是缓和社会矛盾的手段.
------------------------------------------------------------------------------------------------------------------------
