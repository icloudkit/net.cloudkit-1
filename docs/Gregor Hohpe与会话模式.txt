个人简介
Gregor Hohpe是谷歌公司的软件架构师。Gregor是异步消息和SOA领域公认的思想领导者。他是开创性著作《企业集成模式（Enterprise Integration Patterns）》的合著者。2005年，Joel Spolsky将Gregor的文章“星巴克不使用两阶段提交”入选其“最佳软件文章”。

1.现有演讲者的演讲中有多少共同点？你们是否采用同样的模式？你是否看到一些共同性的出现，或者是多种不同的方式仍然在竞争？
我们在track中试图将范围扩大得更宽。Amazon的Jeff仅仅讲到了Amazon的核心服务，例如Storage、SimpleDB、计算云、队列服务等等，就像实际的技术基础设施服务。Salesforce的Dave的内容更多的是交易软件，如服务系统。Frank谈到了GData，这是基于 Atom Publishing的一个层API。后来Jonathan谈到了Yahoo!Pipes，并做了演示。
这些都是完全不同的东西。我们有意这样安排，我认为它们在一起将工作得很好。我可以构建一个mashup，连接上Yahoo!Pipes，从 Salesforce和GData取回一些东西，最终的一部分可以在Amazon上运行，或者将结果数据存到SimpleDB中――可以很容易想象如何将这些集成在一起。
你的问题是说这些之间有什么共同点，我认为它们各自占据了各自的位置，它们也配合得不错。但是它们也都有自己的设计哲学，即它们是不同的：有些是底层服务，而有些是高层服务，如Salesforce提供的自动化操作。
对我来说，连接它们更像是在搭积木。都具有明确的共同主题，包括可扩展性、安全性等等。每个人几乎都必须谈论这些。它们有一些不同。在这里我试图指出一点，即事务怎么办？事务重要么？Frank可能会说“不”，其他人可能会马上举起手来，Jonathan会说“我认为不是，但是我还没准备好举手”，而 Salesforce和Amazon的人认为某种形式的事务的确非常有用。这些广泛的观点对我来说非常有趣。

2.根据我们刚刚谈到有关事务的话题，是否难以扩展？如果需要在全球范围进行工作，是否不能采用事务？
我的观点是在那样大范围内不能使用事务。你可以使用事务，但是与系统大小相比，其范围小得多。当我们了解这一点后，显然在集成模式中，消息也有相同的问题：当你发送消息时，将消息放到队列中也是事务性的，将其从队列中拿出来也是事务性的。 如果你获取消息时失败了，你进行回滚，消息返回到队列中，这样你可以保证只有一个消费者最终读到这条消息。你也可以制作一个组件来读取消息并发送一个回应消息，如果这个操作非常迅速，这样在运行中间你就可以派生新的事务。
读取消息、计算应答并发送消息可以作为一个整体：可以集合为一个事务，即读取消息者拥有其单独的事务。这里存在事务，但是事务并不是全部。当你考虑整个交互过程，可能采用会话模式，比如将请求、响应当作一个事务更好。因为这里往往有至少三个事务：发送最初的请求是第一个事务，服务提供者读取消息、进行处理、发送响应是第二个事务，发送者读取响应是第三个事务。
这使得事情非常有趣，即采用事务比较有保障，但是该保障比系统总体状况少得多。它保证本地的事情，这非常有用。但是它不能保证我发送的消息能够正常接收，其响应消息能够正常发送，以及两者的一致性。你不能保证这些，我认为你不是不想保证，只不过这些保证是系统吞吐量的最大杀手。我认为完成这些保证有点幻想。总会出现某种情况，系统无法正常工作，从而使得整个交互非常复杂，而且可能导致性能很差。
我的经验和哲学就是采用一个简单的解决方案并深入了解其局限，不要采用那些不停地层层累加的方式来添加恢复机制。我看到有些人这样做，最后这些复杂的系统形成了一些非常有害的特点，即没有人可以预测――事情之间产生了死锁情况，所有事情完全崩溃――而在简单的解决方案中，你知道系统能做的事和不能做的事。我赞同这点，而且我也是这样做的。不要做像构建巴别塔那样的事，因为它会被其本身的重量压垮。

3.你是说我们必须学会在缺点、错误、矛盾中生存，并试图处理它们？
我认为是这样的。这听起来有些可怕。计算机是0和1的世界，要么是1要么是0，我么喜欢精确。所以当我们说“学会在不确定中生存”时，听起来有些吓人…状态是个很好的例子：一些可能的事情可以突然爆发出来。另一方面我总是告诉人们不要恐慌，因为现实生活就像这样，世界的功能也是这样，我们处理事情也是这样，我们都有一样的不确定性。所以我认为有一些好消息、也有一些坏消息。这的确有点吓人，但是好消息是，在某种程度上，这些系统实际上更像现实生活系统，它们处理的是同样的问题，它们处理同样的因素，你不能假定一些不存在的事情。星巴克没有两阶段提交，如果你假定它有，则事情会变得比直接处理更糟。
我还有很多事例。我有很多朋友在银行工作。上一次在科罗拉多州，我同eBay的Dan Pritchett聊天，他说交易就像是真实的现金流动。事务派的观点是：在银行账户中，你必须保证这100美元和那100美元的完整，它们原子地从这里流向那里，银行保证了这一点。但是你可能会惊讶这之间会发生什么，这里不仅仅只有两个事务，两条记录。这里有很多事情发生。例如――我不说出银行名字，但我确信所有银行有一样――我朋友告诉我有些银行拥有某些神奇帐户，通过这些神奇的帐号，可以随意地存取资金。我也希望我的名字也是这种账户。这些账户用来处理临时性的事情，即平衡发生的特殊事情，并防止账户向任何方向流失。这些特殊事情的确存在。有时候特殊事情发生了，然后就要采取相应的对策。例如他们弄丢了你的50元，而且你是个好客户，他们将在账户上给你加上50元，这样你就不会看到他们的错误了。
有很多这样发生在幕后的事情。我不是想鼓励大家：“随便做吧，钱不重要，只要做了就好”。假如你做了一个系统可以完成某个功能，但是你必须非常诚实，即你的系统有一定的局限性，你可以编造出系统工作得不那么好的场景，而且你必须解决这个问题。这个方法就是在系统的层次上再加上一个层次，然后假装着你已经构建了一种可以预测的方法，而实际上，这种方法是无法工作的。
在谷歌，我们有管理机器方面的故事。我们最大的哲学不是“如果出错”，而是“何时出错”。我们有大量的机器，所以我们面临着机器经常出错。例如数据丢失、磁盘损坏、CPU过热、机柜起火等等。所有这些都会发生，所以我们必须准备处理这些问题。而不是说，如果我们安装了第二块电源或者其它什么，我们就可以避免事故发生。事故必然会发生。某种程度上说，这种架构恰恰就是现实生活的样子，你必须处理它。总的来说，用钱可以修复许多问题。在面对面的交易中，你可以接受该损失，并给客户返回一些钱，你可以有很多种非系统结构的方法来处理这个问题。我们生活在真实世界里，我回答了这么多，这的确是个有趣的话题。

4.可以合理地认为，至少可以指望人们是诚实的。我认为云计算的带来的问题是你不知道服务是否活得与你期望的时间一样，是否有足够多的服务，是否能达到一定的性能。
非常有趣的话题。实际上存在两种保证，一种是协议和技术的固有的特性，另外一种是服务在两年内将运行良好，他们何时开始收费，是否提高收费。越透明越好，保证的人越多越好。许多服务是免费的。我知道Google就有很多免费服务。问题可能出在你提供何种保证，这个答案简单说来，一般就是我们不提供保证。但是非常非常非常有可能的是，你知道它们将一直提供服务――这对那些使用它的人来说，在一定限制内，往往是标准答案。
因此，快速发展的小企业和初创企业的商业模式正在迅速演变，他们可能需要处理大量其它的不确定因素，而不是处理服务是否在两年内有效的这类问题。这对他们来说不算个大问题。对于已经建立了商业的企业来说，他们可能试图将其某个核心功能移植到某类服务上去，这有很大的不同。他们肯定会吸引更多东西，例如和 Amazon签订合同，你付钱，得到保证，他们承诺服务的可用性，如果服务不可用，你将会得到退款。
我的意思是没有人能给完全的承诺。你也知道这是用多个9来度量的，这里从来都不是用1和0来衡量的。这里从来没有100分，总是有某些不确定因素。所以如果这些人对不确定因素比较诚实，则事情比较好。如果他们处在意外情况，他们做出补偿，大部分时间只是赔钱，这也是最可供补偿的资源。如果我的系统坏了，我给你退钱，这通常是最简便的解决办法。对Google的网站来说――我们提供一些企业级的服务，你可以得到技术支持，例如电子邮件，文字处理。你可以得到企业级服务和一些保证，但是你得付钱。
对于其它所有免费东西来说，主要是一个信任的问题。你知道这是Google，服务通常不会坏掉，一般可以运行一段时间，但是没有人以书面形式写下这一点。这是另一种做生意的方式。对我来说有时候也需要适应。我举例演示一下，其中包括一些云计算的工具。演示中间有一个服务完全失效了，情况非常糟。当时我对任何事情都无能为力，没有人给我任何保证，也没有任何电话支持，我只能希望在接下来的几个小时里，服务会恢复正常。幸亏当时是在一个小会议上。我是一个小例子，但是你可以看到这种事情的确会发生。

5.如果我运行一个24×7小时运行、永不停机的服务，我希望经常部署软件，尤其是用非破坏的方式。这不正是今天云计算所提供的特性么？
是的，对于软件更新的基本问题来说，热更新无需关闭系统。我认为有一些解决方法。在云计算中最流行的方法是――提供将请求路由到不同的服务实例的能力，这是一个较好的抽象方法。例如URI，你不知道到URI背后到底是什么，人们一般有多个数据中心，请求可以被路由到不同的地方去。很多请求就可以依次直接得到更新的服务。
基本上所有人都采用这种方式，原因是：人们软件发布得非常频繁，特别是与Web 2.0有关时，软件的发布周期消失了。新东西随时会出现，同时你也许将发布你的新软件，也许将回收某些不满足要求的软件。大多数人主要做两件事：在某些机器上进行生产，并控制那些消息可以流向新机器。Canary可能是比较合适的软件，人们将1％的流量发送到新服务上，并观察系统中发生的事件，这样就可以控制系统的运行。然后他们缓慢地加快系统的转换。这样你必须处理的事情就是不同的客户使用了不同版本的软件。
这事儿很有趣，即使在Google，我们有时候收到类似的问题，如“哦，我的朋友在Gmail里看到了这样的输入框”，而我却完全不知情。这样也是个好机会，毕竟有人发现了这个新的试验东西。有时候对有些新的特性，有人看到了，有些人又没看到。关键问题在于需要一种版本的兼容性。这样你就可以调和这个矛盾，即一些人谈论新版本，而另一些人谈论其他的版本。
然后，你当然需要确定你是否需要版本之间的关联关系。这样一旦他们谈论新版本时，可以确保总是同一个新版本。当你给出你的会话cookie或其他东西时，处在试验软件中的人至少在本会话中也在同一个试验环境中。否则，将会出现在同一会话中涉及到两个版本软件切换的问题。据我所知，这些是常见的技术，你可能有点多疑，或者你碰到了不同的场景。

6.既然现成的技术可以解决这一问题，你为什么要采取新的做法，你为什么不直接购买能够解决你问题的技术？
我并不主张从零开始建立所有的一切。我只是说明这是一般性的机制，由于这是一种非常常见的问题，你可以买一些有用的解决方案。要小心的一点是，你可以买到的方案能够提供一定的机制，但你仍然有可能在自己的层次里带来问题。因此，既有好处，也有坏处。所以你仍然需要有变化的能力。因为你发布的新软件即使经过所有的测试，仍然可能存在问题。所以如果你购买解决方案，你仍然需要具有可以重新路由和回送某些会话的能力。
就我们而言，我们的确自己构建了很多东西，这只是因为我们拥有非常专有的软件栈。实际上这是一种折中，即是购买还是建造的决定。在大多数情况下，购买可能是个好主意，特别是可靠性非常高的东西。通常随着时间的推移，你会发现你自己所做的东西不如你预想的可靠，也不如直接购买的。购买的东西一般已经经过其它人辛苦的测试过程。这是一个好处，但是你必须在能够自我控制上进行权衡。例如，如果你刚开始建立自己的软件栈，你知道事情到底将如何发展，你可以调整所有的事情。这是一个有关购买还是建造的讨论。最终这是你想要的机制，你可以逐渐地控制机器和用户的流量。


刘涛，博士，毕业于西安交通大学，主要研究网络体系，现在主要从事多核环境下高性能算法的研究与开发工作。曾经进行过多个企业级软件的设计与开发工作。关心开源软件的发展动态，乐于使用开源软件。对前沿的系统软件与技术有浓厚兴趣。
